{"ast":null,"code":"import { Class } from './Class';\nimport * as Util from './Util';\n\n/*\r\n * @class Evented\r\n * @aka L.Evented\r\n * @inherits Class\r\n *\r\n * A set of methods shared between event-powered classes (like `Map` and `Marker`). Generally, events allow you to execute some function when something happens with an object (e.g. the user clicks on the map, causing the map to fire `'click'` event).\r\n *\r\n * @example\r\n *\r\n * ```js\r\n * map.on('click', function(e) {\r\n * \talert(e.latlng);\r\n * } );\r\n * ```\r\n *\r\n * Leaflet deals with event listeners by reference, so if you want to add a listener and then remove it, define it as a function:\r\n *\r\n * ```js\r\n * function onClick(e) { ... }\r\n *\r\n * map.on('click', onClick);\r\n * map.off('click', onClick);\r\n * ```\r\n */\n\nexport var Events = {\n  /* @method on(type: String, fn: Function, context?: Object): this\r\n   * Adds a listener function (`fn`) to a particular event type of the object. You can optionally specify the context of the listener (object the this keyword will point to). You can also pass several space-separated types (e.g. `'click dblclick'`).\r\n   *\r\n   * @alternative\r\n   * @method on(eventMap: Object): this\r\n   * Adds a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`\r\n   */\n  on: function (types, fn, context) {\n    // types can be a map of types/handlers\n    if (typeof types === 'object') {\n      for (var type in types) {\n        // we don't process space-separated events here for performance;\n        // it's a hot path since Layer uses the on(obj) syntax\n        this._on(type, types[type], fn);\n      }\n    } else {\n      // types can be a string of space-separated words\n      types = Util.splitWords(types);\n      for (var i = 0, len = types.length; i < len; i++) {\n        this._on(types[i], fn, context);\n      }\n    }\n    return this;\n  },\n  /* @method off(type: String, fn?: Function, context?: Object): this\r\n   * Removes a previously added listener function. If no function is specified, it will remove all the listeners of that particular event from the object. Note that if you passed a custom context to `on`, you must pass the same context to `off` in order to remove the listener.\r\n   *\r\n   * @alternative\r\n   * @method off(eventMap: Object): this\r\n   * Removes a set of type/listener pairs.\r\n   *\r\n   * @alternative\r\n   * @method off: this\r\n   * Removes all listeners to all events on the object. This includes implicitly attached events.\r\n   */\n  off: function (types, fn, context) {\n    if (!arguments.length) {\n      // clear all listeners if called without arguments\n      delete this._events;\n    } else if (typeof types === 'object') {\n      for (var type in types) {\n        this._off(type, types[type], fn);\n      }\n    } else {\n      types = Util.splitWords(types);\n      var removeAll = arguments.length === 1;\n      for (var i = 0, len = types.length; i < len; i++) {\n        if (removeAll) {\n          this._off(types[i]);\n        } else {\n          this._off(types[i], fn, context);\n        }\n      }\n    }\n    return this;\n  },\n  // attach listener (without syntactic sugar now)\n  _on: function (type, fn, context, _once) {\n    if (typeof fn !== 'function') {\n      console.warn('wrong listener type: ' + typeof fn);\n      return;\n    }\n\n    // check if fn already there\n    if (this._listens(type, fn, context) !== false) {\n      return;\n    }\n    if (context === this) {\n      // Less memory footprint.\n      context = undefined;\n    }\n    var newListener = {\n      fn: fn,\n      ctx: context\n    };\n    if (_once) {\n      newListener.once = true;\n    }\n    this._events = this._events || {};\n    this._events[type] = this._events[type] || [];\n    this._events[type].push(newListener);\n  },\n  _off: function (type, fn, context) {\n    var listeners, i, len;\n    if (!this._events) {\n      return;\n    }\n    listeners = this._events[type];\n    if (!listeners) {\n      return;\n    }\n    if (arguments.length === 1) {\n      // remove all\n      if (this._firingCount) {\n        // Set all removed listeners to noop\n        // so they are not called if remove happens in fire\n        for (i = 0, len = listeners.length; i < len; i++) {\n          listeners[i].fn = Util.falseFn;\n        }\n      }\n      // clear all listeners for a type if function isn't specified\n      delete this._events[type];\n      return;\n    }\n    if (typeof fn !== 'function') {\n      console.warn('wrong listener type: ' + typeof fn);\n      return;\n    }\n\n    // find fn and remove it\n    var index = this._listens(type, fn, context);\n    if (index !== false) {\n      var listener = listeners[index];\n      if (this._firingCount) {\n        // set the removed listener to noop so that's not called if remove happens in fire\n        listener.fn = Util.falseFn;\n\n        /* copy array in case events are being fired */\n        this._events[type] = listeners = listeners.slice();\n      }\n      listeners.splice(index, 1);\n    }\n  },\n  // @method fire(type: String, data?: Object, propagate?: Boolean): this\n  // Fires an event of the specified type. You can optionally provide a data\n  // object — the first argument of the listener function will contain its\n  // properties. The event can optionally be propagated to event parents.\n  fire: function (type, data, propagate) {\n    if (!this.listens(type, propagate)) {\n      return this;\n    }\n    var event = Util.extend({}, data, {\n      type: type,\n      target: this,\n      sourceTarget: data && data.sourceTarget || this\n    });\n    if (this._events) {\n      var listeners = this._events[type];\n      if (listeners) {\n        this._firingCount = this._firingCount + 1 || 1;\n        for (var i = 0, len = listeners.length; i < len; i++) {\n          var l = listeners[i];\n          // off overwrites l.fn, so we need to copy fn to a var\n          var fn = l.fn;\n          if (l.once) {\n            this.off(type, fn, l.ctx);\n          }\n          fn.call(l.ctx || this, event);\n        }\n        this._firingCount--;\n      }\n    }\n    if (propagate) {\n      // propagate the event to parents (set with addEventParent)\n      this._propagateEvent(event);\n    }\n    return this;\n  },\n  // @method listens(type: String, propagate?: Boolean): Boolean\n  // @method listens(type: String, fn: Function, context?: Object, propagate?: Boolean): Boolean\n  // Returns `true` if a particular event type has any listeners attached to it.\n  // The verification can optionally be propagated, it will return `true` if parents have the listener attached to it.\n  listens: function (type, fn, context, propagate) {\n    if (typeof type !== 'string') {\n      console.warn('\"string\" type argument expected');\n    }\n\n    // we don't overwrite the input `fn` value, because we need to use it for propagation\n    var _fn = fn;\n    if (typeof fn !== 'function') {\n      propagate = !!fn;\n      _fn = undefined;\n      context = undefined;\n    }\n    var listeners = this._events && this._events[type];\n    if (listeners && listeners.length) {\n      if (this._listens(type, _fn, context) !== false) {\n        return true;\n      }\n    }\n    if (propagate) {\n      // also check parents for listeners if event propagates\n      for (var id in this._eventParents) {\n        if (this._eventParents[id].listens(type, fn, context, propagate)) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  // returns the index (number) or false\n  _listens: function (type, fn, context) {\n    if (!this._events) {\n      return false;\n    }\n    var listeners = this._events[type] || [];\n    if (!fn) {\n      return !!listeners.length;\n    }\n    if (context === this) {\n      // Less memory footprint.\n      context = undefined;\n    }\n    for (var i = 0, len = listeners.length; i < len; i++) {\n      if (listeners[i].fn === fn && listeners[i].ctx === context) {\n        return i;\n      }\n    }\n    return false;\n  },\n  // @method once(…): this\n  // Behaves as [`on(…)`](#evented-on), except the listener will only get fired once and then removed.\n  once: function (types, fn, context) {\n    // types can be a map of types/handlers\n    if (typeof types === 'object') {\n      for (var type in types) {\n        // we don't process space-separated events here for performance;\n        // it's a hot path since Layer uses the on(obj) syntax\n        this._on(type, types[type], fn, true);\n      }\n    } else {\n      // types can be a string of space-separated words\n      types = Util.splitWords(types);\n      for (var i = 0, len = types.length; i < len; i++) {\n        this._on(types[i], fn, context, true);\n      }\n    }\n    return this;\n  },\n  // @method addEventParent(obj: Evented): this\n  // Adds an event parent - an `Evented` that will receive propagated events\n  addEventParent: function (obj) {\n    this._eventParents = this._eventParents || {};\n    this._eventParents[Util.stamp(obj)] = obj;\n    return this;\n  },\n  // @method removeEventParent(obj: Evented): this\n  // Removes an event parent, so it will stop receiving propagated events\n  removeEventParent: function (obj) {\n    if (this._eventParents) {\n      delete this._eventParents[Util.stamp(obj)];\n    }\n    return this;\n  },\n  _propagateEvent: function (e) {\n    for (var id in this._eventParents) {\n      this._eventParents[id].fire(e.type, Util.extend({\n        layer: e.target,\n        propagatedFrom: e.target\n      }, e), true);\n    }\n  }\n};\n\n// aliases; we should ditch those eventually\n\n// @method addEventListener(…): this\n// Alias to [`on(…)`](#evented-on)\nEvents.addEventListener = Events.on;\n\n// @method removeEventListener(…): this\n// Alias to [`off(…)`](#evented-off)\n\n// @method clearAllEventListeners(…): this\n// Alias to [`off()`](#evented-off)\nEvents.removeEventListener = Events.clearAllEventListeners = Events.off;\n\n// @method addOneTimeEventListener(…): this\n// Alias to [`once(…)`](#evented-once)\nEvents.addOneTimeEventListener = Events.once;\n\n// @method fireEvent(…): this\n// Alias to [`fire(…)`](#evented-fire)\nEvents.fireEvent = Events.fire;\n\n// @method hasEventListeners(…): Boolean\n// Alias to [`listens(…)`](#evented-listens)\nEvents.hasEventListeners = Events.listens;\nexport var Evented = Class.extend(Events);","map":{"version":3,"names":["Class","Util","Events","on","types","fn","context","type","_on","splitWords","i","len","length","off","arguments","_events","_off","removeAll","_once","console","warn","_listens","undefined","newListener","ctx","once","push","listeners","_firingCount","falseFn","index","listener","slice","splice","fire","data","propagate","listens","event","extend","target","sourceTarget","l","call","_propagateEvent","_fn","id","_eventParents","addEventParent","obj","stamp","removeEventParent","e","layer","propagatedFrom","addEventListener","removeEventListener","clearAllEventListeners","addOneTimeEventListener","fireEvent","hasEventListeners","Evented"],"sources":["C:/Users/aless/OneDrive/Área de Trabalho/Registro Ponto front-end GitHub/ReactProjects/my-app/node_modules/leaflet/src/core/Events.js"],"sourcesContent":["import {Class} from './Class';\r\nimport * as Util from './Util';\r\n\r\n/*\r\n * @class Evented\r\n * @aka L.Evented\r\n * @inherits Class\r\n *\r\n * A set of methods shared between event-powered classes (like `Map` and `Marker`). Generally, events allow you to execute some function when something happens with an object (e.g. the user clicks on the map, causing the map to fire `'click'` event).\r\n *\r\n * @example\r\n *\r\n * ```js\r\n * map.on('click', function(e) {\r\n * \talert(e.latlng);\r\n * } );\r\n * ```\r\n *\r\n * Leaflet deals with event listeners by reference, so if you want to add a listener and then remove it, define it as a function:\r\n *\r\n * ```js\r\n * function onClick(e) { ... }\r\n *\r\n * map.on('click', onClick);\r\n * map.off('click', onClick);\r\n * ```\r\n */\r\n\r\nexport var Events = {\r\n\t/* @method on(type: String, fn: Function, context?: Object): this\r\n\t * Adds a listener function (`fn`) to a particular event type of the object. You can optionally specify the context of the listener (object the this keyword will point to). You can also pass several space-separated types (e.g. `'click dblclick'`).\r\n\t *\r\n\t * @alternative\r\n\t * @method on(eventMap: Object): this\r\n\t * Adds a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`\r\n\t */\r\n\ton: function (types, fn, context) {\r\n\r\n\t\t// types can be a map of types/handlers\r\n\t\tif (typeof types === 'object') {\r\n\t\t\tfor (var type in types) {\r\n\t\t\t\t// we don't process space-separated events here for performance;\r\n\t\t\t\t// it's a hot path since Layer uses the on(obj) syntax\r\n\t\t\t\tthis._on(type, types[type], fn);\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\t\t\t// types can be a string of space-separated words\r\n\t\t\ttypes = Util.splitWords(types);\r\n\r\n\t\t\tfor (var i = 0, len = types.length; i < len; i++) {\r\n\t\t\t\tthis._on(types[i], fn, context);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\t/* @method off(type: String, fn?: Function, context?: Object): this\r\n\t * Removes a previously added listener function. If no function is specified, it will remove all the listeners of that particular event from the object. Note that if you passed a custom context to `on`, you must pass the same context to `off` in order to remove the listener.\r\n\t *\r\n\t * @alternative\r\n\t * @method off(eventMap: Object): this\r\n\t * Removes a set of type/listener pairs.\r\n\t *\r\n\t * @alternative\r\n\t * @method off: this\r\n\t * Removes all listeners to all events on the object. This includes implicitly attached events.\r\n\t */\r\n\toff: function (types, fn, context) {\r\n\r\n\t\tif (!arguments.length) {\r\n\t\t\t// clear all listeners if called without arguments\r\n\t\t\tdelete this._events;\r\n\r\n\t\t} else if (typeof types === 'object') {\r\n\t\t\tfor (var type in types) {\r\n\t\t\t\tthis._off(type, types[type], fn);\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\t\t\ttypes = Util.splitWords(types);\r\n\r\n\t\t\tvar removeAll = arguments.length === 1;\r\n\t\t\tfor (var i = 0, len = types.length; i < len; i++) {\r\n\t\t\t\tif (removeAll) {\r\n\t\t\t\t\tthis._off(types[i]);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthis._off(types[i], fn, context);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\t// attach listener (without syntactic sugar now)\r\n\t_on: function (type, fn, context, _once) {\r\n\t\tif (typeof fn !== 'function') {\r\n\t\t\tconsole.warn('wrong listener type: ' + typeof fn);\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// check if fn already there\r\n\t\tif (this._listens(type, fn, context) !== false) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tif (context === this) {\r\n\t\t\t// Less memory footprint.\r\n\t\t\tcontext = undefined;\r\n\t\t}\r\n\r\n\t\tvar newListener = {fn: fn, ctx: context};\r\n\t\tif (_once) {\r\n\t\t\tnewListener.once = true;\r\n\t\t}\r\n\r\n\t\tthis._events = this._events || {};\r\n\t\tthis._events[type] = this._events[type] || [];\r\n\t\tthis._events[type].push(newListener);\r\n\t},\r\n\r\n\t_off: function (type, fn, context) {\r\n\t\tvar listeners,\r\n\t\t    i,\r\n\t\t    len;\r\n\r\n\t\tif (!this._events) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tlisteners = this._events[type];\r\n\t\tif (!listeners) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tif (arguments.length === 1) { // remove all\r\n\t\t\tif (this._firingCount) {\r\n\t\t\t\t// Set all removed listeners to noop\r\n\t\t\t\t// so they are not called if remove happens in fire\r\n\t\t\t\tfor (i = 0, len = listeners.length; i < len; i++) {\r\n\t\t\t\t\tlisteners[i].fn = Util.falseFn;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// clear all listeners for a type if function isn't specified\r\n\t\t\tdelete this._events[type];\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tif (typeof fn !== 'function') {\r\n\t\t\tconsole.warn('wrong listener type: ' + typeof fn);\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// find fn and remove it\r\n\t\tvar index = this._listens(type, fn, context);\r\n\t\tif (index !== false) {\r\n\t\t\tvar listener = listeners[index];\r\n\t\t\tif (this._firingCount) {\r\n\t\t\t\t// set the removed listener to noop so that's not called if remove happens in fire\r\n\t\t\t\tlistener.fn = Util.falseFn;\r\n\r\n\t\t\t\t/* copy array in case events are being fired */\r\n\t\t\t\tthis._events[type] = listeners = listeners.slice();\r\n\t\t\t}\r\n\t\t\tlisteners.splice(index, 1);\r\n\t\t}\r\n\t},\r\n\r\n\t// @method fire(type: String, data?: Object, propagate?: Boolean): this\r\n\t// Fires an event of the specified type. You can optionally provide a data\r\n\t// object — the first argument of the listener function will contain its\r\n\t// properties. The event can optionally be propagated to event parents.\r\n\tfire: function (type, data, propagate) {\r\n\t\tif (!this.listens(type, propagate)) { return this; }\r\n\r\n\t\tvar event = Util.extend({}, data, {\r\n\t\t\ttype: type,\r\n\t\t\ttarget: this,\r\n\t\t\tsourceTarget: data && data.sourceTarget || this\r\n\t\t});\r\n\r\n\t\tif (this._events) {\r\n\t\t\tvar listeners = this._events[type];\r\n\t\t\tif (listeners) {\r\n\t\t\t\tthis._firingCount = (this._firingCount + 1) || 1;\r\n\t\t\t\tfor (var i = 0, len = listeners.length; i < len; i++) {\r\n\t\t\t\t\tvar l = listeners[i];\r\n\t\t\t\t\t// off overwrites l.fn, so we need to copy fn to a var\r\n\t\t\t\t\tvar fn = l.fn;\r\n\t\t\t\t\tif (l.once) {\r\n\t\t\t\t\t\tthis.off(type, fn, l.ctx);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tfn.call(l.ctx || this, event);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis._firingCount--;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (propagate) {\r\n\t\t\t// propagate the event to parents (set with addEventParent)\r\n\t\t\tthis._propagateEvent(event);\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\t// @method listens(type: String, propagate?: Boolean): Boolean\r\n\t// @method listens(type: String, fn: Function, context?: Object, propagate?: Boolean): Boolean\r\n\t// Returns `true` if a particular event type has any listeners attached to it.\r\n\t// The verification can optionally be propagated, it will return `true` if parents have the listener attached to it.\r\n\tlistens: function (type, fn, context, propagate) {\r\n\t\tif (typeof type !== 'string') {\r\n\t\t\tconsole.warn('\"string\" type argument expected');\r\n\t\t}\r\n\r\n\t\t// we don't overwrite the input `fn` value, because we need to use it for propagation\r\n\t\tvar _fn = fn;\r\n\t\tif (typeof fn !== 'function') {\r\n\t\t\tpropagate = !!fn;\r\n\t\t\t_fn = undefined;\r\n\t\t\tcontext = undefined;\r\n\t\t}\r\n\r\n\t\tvar listeners = this._events && this._events[type];\r\n\t\tif (listeners && listeners.length) {\r\n\t\t\tif (this._listens(type, _fn, context) !== false) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (propagate) {\r\n\t\t\t// also check parents for listeners if event propagates\r\n\t\t\tfor (var id in this._eventParents) {\r\n\t\t\t\tif (this._eventParents[id].listens(type, fn, context, propagate)) { return true; }\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn false;\r\n\t},\r\n\r\n\t// returns the index (number) or false\r\n\t_listens: function (type, fn, context) {\r\n\t\tif (!this._events) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tvar listeners = this._events[type] || [];\r\n\t\tif (!fn) {\r\n\t\t\treturn !!listeners.length;\r\n\t\t}\r\n\r\n\t\tif (context === this) {\r\n\t\t\t// Less memory footprint.\r\n\t\t\tcontext = undefined;\r\n\t\t}\r\n\r\n\t\tfor (var i = 0, len = listeners.length; i < len; i++) {\r\n\t\t\tif (listeners[i].fn === fn && listeners[i].ctx === context) {\r\n\t\t\t\treturn i;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn false;\r\n\r\n\t},\r\n\r\n\t// @method once(…): this\r\n\t// Behaves as [`on(…)`](#evented-on), except the listener will only get fired once and then removed.\r\n\tonce: function (types, fn, context) {\r\n\r\n\t\t// types can be a map of types/handlers\r\n\t\tif (typeof types === 'object') {\r\n\t\t\tfor (var type in types) {\r\n\t\t\t\t// we don't process space-separated events here for performance;\r\n\t\t\t\t// it's a hot path since Layer uses the on(obj) syntax\r\n\t\t\t\tthis._on(type, types[type], fn, true);\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\t\t\t// types can be a string of space-separated words\r\n\t\t\ttypes = Util.splitWords(types);\r\n\r\n\t\t\tfor (var i = 0, len = types.length; i < len; i++) {\r\n\t\t\t\tthis._on(types[i], fn, context, true);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\t// @method addEventParent(obj: Evented): this\r\n\t// Adds an event parent - an `Evented` that will receive propagated events\r\n\taddEventParent: function (obj) {\r\n\t\tthis._eventParents = this._eventParents || {};\r\n\t\tthis._eventParents[Util.stamp(obj)] = obj;\r\n\t\treturn this;\r\n\t},\r\n\r\n\t// @method removeEventParent(obj: Evented): this\r\n\t// Removes an event parent, so it will stop receiving propagated events\r\n\tremoveEventParent: function (obj) {\r\n\t\tif (this._eventParents) {\r\n\t\t\tdelete this._eventParents[Util.stamp(obj)];\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\t_propagateEvent: function (e) {\r\n\t\tfor (var id in this._eventParents) {\r\n\t\t\tthis._eventParents[id].fire(e.type, Util.extend({\r\n\t\t\t\tlayer: e.target,\r\n\t\t\t\tpropagatedFrom: e.target\r\n\t\t\t}, e), true);\r\n\t\t}\r\n\t}\r\n};\r\n\r\n// aliases; we should ditch those eventually\r\n\r\n// @method addEventListener(…): this\r\n// Alias to [`on(…)`](#evented-on)\r\nEvents.addEventListener = Events.on;\r\n\r\n// @method removeEventListener(…): this\r\n// Alias to [`off(…)`](#evented-off)\r\n\r\n// @method clearAllEventListeners(…): this\r\n// Alias to [`off()`](#evented-off)\r\nEvents.removeEventListener = Events.clearAllEventListeners = Events.off;\r\n\r\n// @method addOneTimeEventListener(…): this\r\n// Alias to [`once(…)`](#evented-once)\r\nEvents.addOneTimeEventListener = Events.once;\r\n\r\n// @method fireEvent(…): this\r\n// Alias to [`fire(…)`](#evented-fire)\r\nEvents.fireEvent = Events.fire;\r\n\r\n// @method hasEventListeners(…): Boolean\r\n// Alias to [`listens(…)`](#evented-listens)\r\nEvents.hasEventListeners = Events.listens;\r\n\r\nexport var Evented = Class.extend(Events);\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}