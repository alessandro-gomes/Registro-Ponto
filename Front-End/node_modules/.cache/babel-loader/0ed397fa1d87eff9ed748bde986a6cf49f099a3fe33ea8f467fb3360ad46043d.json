{"ast":null,"code":"import { Bounds } from '../../geometry/Bounds';\nimport { LatLng } from '../LatLng';\nimport { LatLngBounds } from '../LatLngBounds';\nimport * as Util from '../../core/Util';\n\n/*\r\n * @namespace CRS\r\n * @crs L.CRS.Base\r\n * Object that defines coordinate reference systems for projecting\r\n * geographical points into pixel (screen) coordinates and back (and to\r\n * coordinates in other units for [WMS](https://en.wikipedia.org/wiki/Web_Map_Service) services). See\r\n * [spatial reference system](https://en.wikipedia.org/wiki/Spatial_reference_system).\r\n *\r\n * Leaflet defines the most usual CRSs by default. If you want to use a\r\n * CRS not defined by default, take a look at the\r\n * [Proj4Leaflet](https://github.com/kartena/Proj4Leaflet) plugin.\r\n *\r\n * Note that the CRS instances do not inherit from Leaflet's `Class` object,\r\n * and can't be instantiated. Also, new classes can't inherit from them,\r\n * and methods can't be added to them with the `include` function.\r\n */\n\nexport var CRS = {\n  // @method latLngToPoint(latlng: LatLng, zoom: Number): Point\n  // Projects geographical coordinates into pixel coordinates for a given zoom.\n  latLngToPoint: function (latlng, zoom) {\n    var projectedPoint = this.projection.project(latlng),\n      scale = this.scale(zoom);\n    return this.transformation._transform(projectedPoint, scale);\n  },\n  // @method pointToLatLng(point: Point, zoom: Number): LatLng\n  // The inverse of `latLngToPoint`. Projects pixel coordinates on a given\n  // zoom into geographical coordinates.\n  pointToLatLng: function (point, zoom) {\n    var scale = this.scale(zoom),\n      untransformedPoint = this.transformation.untransform(point, scale);\n    return this.projection.unproject(untransformedPoint);\n  },\n  // @method project(latlng: LatLng): Point\n  // Projects geographical coordinates into coordinates in units accepted for\n  // this CRS (e.g. meters for EPSG:3857, for passing it to WMS services).\n  project: function (latlng) {\n    return this.projection.project(latlng);\n  },\n  // @method unproject(point: Point): LatLng\n  // Given a projected coordinate returns the corresponding LatLng.\n  // The inverse of `project`.\n  unproject: function (point) {\n    return this.projection.unproject(point);\n  },\n  // @method scale(zoom: Number): Number\n  // Returns the scale used when transforming projected coordinates into\n  // pixel coordinates for a particular zoom. For example, it returns\n  // `256 * 2^zoom` for Mercator-based CRS.\n  scale: function (zoom) {\n    return 256 * Math.pow(2, zoom);\n  },\n  // @method zoom(scale: Number): Number\n  // Inverse of `scale()`, returns the zoom level corresponding to a scale\n  // factor of `scale`.\n  zoom: function (scale) {\n    return Math.log(scale / 256) / Math.LN2;\n  },\n  // @method getProjectedBounds(zoom: Number): Bounds\n  // Returns the projection's bounds scaled and transformed for the provided `zoom`.\n  getProjectedBounds: function (zoom) {\n    if (this.infinite) {\n      return null;\n    }\n    var b = this.projection.bounds,\n      s = this.scale(zoom),\n      min = this.transformation.transform(b.min, s),\n      max = this.transformation.transform(b.max, s);\n    return new Bounds(min, max);\n  },\n  // @method distance(latlng1: LatLng, latlng2: LatLng): Number\n  // Returns the distance between two geographical coordinates.\n\n  // @property code: String\n  // Standard code name of the CRS passed into WMS services (e.g. `'EPSG:3857'`)\n  //\n  // @property wrapLng: Number[]\n  // An array of two numbers defining whether the longitude (horizontal) coordinate\n  // axis wraps around a given range and how. Defaults to `[-180, 180]` in most\n  // geographical CRSs. If `undefined`, the longitude axis does not wrap around.\n  //\n  // @property wrapLat: Number[]\n  // Like `wrapLng`, but for the latitude (vertical) axis.\n\n  // wrapLng: [min, max],\n  // wrapLat: [min, max],\n\n  // @property infinite: Boolean\n  // If true, the coordinate space will be unbounded (infinite in both axes)\n  infinite: false,\n  // @method wrapLatLng(latlng: LatLng): LatLng\n  // Returns a `LatLng` where lat and lng has been wrapped according to the\n  // CRS's `wrapLat` and `wrapLng` properties, if they are outside the CRS's bounds.\n  wrapLatLng: function (latlng) {\n    var lng = this.wrapLng ? Util.wrapNum(latlng.lng, this.wrapLng, true) : latlng.lng,\n      lat = this.wrapLat ? Util.wrapNum(latlng.lat, this.wrapLat, true) : latlng.lat,\n      alt = latlng.alt;\n    return new LatLng(lat, lng, alt);\n  },\n  // @method wrapLatLngBounds(bounds: LatLngBounds): LatLngBounds\n  // Returns a `LatLngBounds` with the same size as the given one, ensuring\n  // that its center is within the CRS's bounds.\n  // Only accepts actual `L.LatLngBounds` instances, not arrays.\n  wrapLatLngBounds: function (bounds) {\n    var center = bounds.getCenter(),\n      newCenter = this.wrapLatLng(center),\n      latShift = center.lat - newCenter.lat,\n      lngShift = center.lng - newCenter.lng;\n    if (latShift === 0 && lngShift === 0) {\n      return bounds;\n    }\n    var sw = bounds.getSouthWest(),\n      ne = bounds.getNorthEast(),\n      newSw = new LatLng(sw.lat - latShift, sw.lng - lngShift),\n      newNe = new LatLng(ne.lat - latShift, ne.lng - lngShift);\n    return new LatLngBounds(newSw, newNe);\n  }\n};","map":{"version":3,"names":["Bounds","LatLng","LatLngBounds","Util","CRS","latLngToPoint","latlng","zoom","projectedPoint","projection","project","scale","transformation","_transform","pointToLatLng","point","untransformedPoint","untransform","unproject","Math","pow","log","LN2","getProjectedBounds","infinite","b","bounds","s","min","transform","max","wrapLatLng","lng","wrapLng","wrapNum","lat","wrapLat","alt","wrapLatLngBounds","center","getCenter","newCenter","latShift","lngShift","sw","getSouthWest","ne","getNorthEast","newSw","newNe"],"sources":["C:/Users/aless/OneDrive/√Årea de Trabalho/Registro Ponto front-end GitHub/ReactProjects/my-app/node_modules/leaflet/src/geo/crs/CRS.js"],"sourcesContent":["\r\nimport {Bounds} from '../../geometry/Bounds';\r\nimport {LatLng} from '../LatLng';\r\nimport {LatLngBounds} from '../LatLngBounds';\r\nimport * as Util from '../../core/Util';\r\n\r\n/*\r\n * @namespace CRS\r\n * @crs L.CRS.Base\r\n * Object that defines coordinate reference systems for projecting\r\n * geographical points into pixel (screen) coordinates and back (and to\r\n * coordinates in other units for [WMS](https://en.wikipedia.org/wiki/Web_Map_Service) services). See\r\n * [spatial reference system](https://en.wikipedia.org/wiki/Spatial_reference_system).\r\n *\r\n * Leaflet defines the most usual CRSs by default. If you want to use a\r\n * CRS not defined by default, take a look at the\r\n * [Proj4Leaflet](https://github.com/kartena/Proj4Leaflet) plugin.\r\n *\r\n * Note that the CRS instances do not inherit from Leaflet's `Class` object,\r\n * and can't be instantiated. Also, new classes can't inherit from them,\r\n * and methods can't be added to them with the `include` function.\r\n */\r\n\r\nexport var CRS = {\r\n\t// @method latLngToPoint(latlng: LatLng, zoom: Number): Point\r\n\t// Projects geographical coordinates into pixel coordinates for a given zoom.\r\n\tlatLngToPoint: function (latlng, zoom) {\r\n\t\tvar projectedPoint = this.projection.project(latlng),\r\n\t\t    scale = this.scale(zoom);\r\n\r\n\t\treturn this.transformation._transform(projectedPoint, scale);\r\n\t},\r\n\r\n\t// @method pointToLatLng(point: Point, zoom: Number): LatLng\r\n\t// The inverse of `latLngToPoint`. Projects pixel coordinates on a given\r\n\t// zoom into geographical coordinates.\r\n\tpointToLatLng: function (point, zoom) {\r\n\t\tvar scale = this.scale(zoom),\r\n\t\t    untransformedPoint = this.transformation.untransform(point, scale);\r\n\r\n\t\treturn this.projection.unproject(untransformedPoint);\r\n\t},\r\n\r\n\t// @method project(latlng: LatLng): Point\r\n\t// Projects geographical coordinates into coordinates in units accepted for\r\n\t// this CRS (e.g. meters for EPSG:3857, for passing it to WMS services).\r\n\tproject: function (latlng) {\r\n\t\treturn this.projection.project(latlng);\r\n\t},\r\n\r\n\t// @method unproject(point: Point): LatLng\r\n\t// Given a projected coordinate returns the corresponding LatLng.\r\n\t// The inverse of `project`.\r\n\tunproject: function (point) {\r\n\t\treturn this.projection.unproject(point);\r\n\t},\r\n\r\n\t// @method scale(zoom: Number): Number\r\n\t// Returns the scale used when transforming projected coordinates into\r\n\t// pixel coordinates for a particular zoom. For example, it returns\r\n\t// `256 * 2^zoom` for Mercator-based CRS.\r\n\tscale: function (zoom) {\r\n\t\treturn 256 * Math.pow(2, zoom);\r\n\t},\r\n\r\n\t// @method zoom(scale: Number): Number\r\n\t// Inverse of `scale()`, returns the zoom level corresponding to a scale\r\n\t// factor of `scale`.\r\n\tzoom: function (scale) {\r\n\t\treturn Math.log(scale / 256) / Math.LN2;\r\n\t},\r\n\r\n\t// @method getProjectedBounds(zoom: Number): Bounds\r\n\t// Returns the projection's bounds scaled and transformed for the provided `zoom`.\r\n\tgetProjectedBounds: function (zoom) {\r\n\t\tif (this.infinite) { return null; }\r\n\r\n\t\tvar b = this.projection.bounds,\r\n\t\t    s = this.scale(zoom),\r\n\t\t    min = this.transformation.transform(b.min, s),\r\n\t\t    max = this.transformation.transform(b.max, s);\r\n\r\n\t\treturn new Bounds(min, max);\r\n\t},\r\n\r\n\t// @method distance(latlng1: LatLng, latlng2: LatLng): Number\r\n\t// Returns the distance between two geographical coordinates.\r\n\r\n\t// @property code: String\r\n\t// Standard code name of the CRS passed into WMS services (e.g. `'EPSG:3857'`)\r\n\t//\r\n\t// @property wrapLng: Number[]\r\n\t// An array of two numbers defining whether the longitude (horizontal) coordinate\r\n\t// axis wraps around a given range and how. Defaults to `[-180, 180]` in most\r\n\t// geographical CRSs. If `undefined`, the longitude axis does not wrap around.\r\n\t//\r\n\t// @property wrapLat: Number[]\r\n\t// Like `wrapLng`, but for the latitude (vertical) axis.\r\n\r\n\t// wrapLng: [min, max],\r\n\t// wrapLat: [min, max],\r\n\r\n\t// @property infinite: Boolean\r\n\t// If true, the coordinate space will be unbounded (infinite in both axes)\r\n\tinfinite: false,\r\n\r\n\t// @method wrapLatLng(latlng: LatLng): LatLng\r\n\t// Returns a `LatLng` where lat and lng has been wrapped according to the\r\n\t// CRS's `wrapLat` and `wrapLng` properties, if they are outside the CRS's bounds.\r\n\twrapLatLng: function (latlng) {\r\n\t\tvar lng = this.wrapLng ? Util.wrapNum(latlng.lng, this.wrapLng, true) : latlng.lng,\r\n\t\t    lat = this.wrapLat ? Util.wrapNum(latlng.lat, this.wrapLat, true) : latlng.lat,\r\n\t\t    alt = latlng.alt;\r\n\r\n\t\treturn new LatLng(lat, lng, alt);\r\n\t},\r\n\r\n\t// @method wrapLatLngBounds(bounds: LatLngBounds): LatLngBounds\r\n\t// Returns a `LatLngBounds` with the same size as the given one, ensuring\r\n\t// that its center is within the CRS's bounds.\r\n\t// Only accepts actual `L.LatLngBounds` instances, not arrays.\r\n\twrapLatLngBounds: function (bounds) {\r\n\t\tvar center = bounds.getCenter(),\r\n\t\t    newCenter = this.wrapLatLng(center),\r\n\t\t    latShift = center.lat - newCenter.lat,\r\n\t\t    lngShift = center.lng - newCenter.lng;\r\n\r\n\t\tif (latShift === 0 && lngShift === 0) {\r\n\t\t\treturn bounds;\r\n\t\t}\r\n\r\n\t\tvar sw = bounds.getSouthWest(),\r\n\t\t    ne = bounds.getNorthEast(),\r\n\t\t    newSw = new LatLng(sw.lat - latShift, sw.lng - lngShift),\r\n\t\t    newNe = new LatLng(ne.lat - latShift, ne.lng - lngShift);\r\n\r\n\t\treturn new LatLngBounds(newSw, newNe);\r\n\t}\r\n};\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}