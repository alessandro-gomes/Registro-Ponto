{"ast":null,"code":"import { Point } from './Point';\nimport * as Util from '../core/Util';\n\n/*\r\n * @class Transformation\r\n * @aka L.Transformation\r\n *\r\n * Represents an affine transformation: a set of coefficients `a`, `b`, `c`, `d`\r\n * for transforming a point of a form `(x, y)` into `(a*x + b, c*y + d)` and doing\r\n * the reverse. Used by Leaflet in its projections code.\r\n *\r\n * @example\r\n *\r\n * ```js\r\n * var transformation = L.transformation(2, 5, -1, 10),\r\n * \tp = L.point(1, 2),\r\n * \tp2 = transformation.transform(p), //  L.point(7, 8)\r\n * \tp3 = transformation.untransform(p2); //  L.point(1, 2)\r\n * ```\r\n */\n\n// factory new L.Transformation(a: Number, b: Number, c: Number, d: Number)\n// Creates a `Transformation` object with the given coefficients.\nexport function Transformation(a, b, c, d) {\n  if (Util.isArray(a)) {\n    // use array properties\n    this._a = a[0];\n    this._b = a[1];\n    this._c = a[2];\n    this._d = a[3];\n    return;\n  }\n  this._a = a;\n  this._b = b;\n  this._c = c;\n  this._d = d;\n}\nTransformation.prototype = {\n  // @method transform(point: Point, scale?: Number): Point\n  // Returns a transformed point, optionally multiplied by the given scale.\n  // Only accepts actual `L.Point` instances, not arrays.\n  transform: function (point, scale) {\n    // (Point, Number) -> Point\n    return this._transform(point.clone(), scale);\n  },\n  // destructive transform (faster)\n  _transform: function (point, scale) {\n    scale = scale || 1;\n    point.x = scale * (this._a * point.x + this._b);\n    point.y = scale * (this._c * point.y + this._d);\n    return point;\n  },\n  // @method untransform(point: Point, scale?: Number): Point\n  // Returns the reverse transformation of the given point, optionally divided\n  // by the given scale. Only accepts actual `L.Point` instances, not arrays.\n  untransform: function (point, scale) {\n    scale = scale || 1;\n    return new Point((point.x / scale - this._b) / this._a, (point.y / scale - this._d) / this._c);\n  }\n};\n\n// factory L.transformation(a: Number, b: Number, c: Number, d: Number)\n\n// @factory L.transformation(a: Number, b: Number, c: Number, d: Number)\n// Instantiates a Transformation object with the given coefficients.\n\n// @alternative\n// @factory L.transformation(coefficients: Array): Transformation\n// Expects an coefficients array of the form\n// `[a: Number, b: Number, c: Number, d: Number]`.\n\nexport function toTransformation(a, b, c, d) {\n  return new Transformation(a, b, c, d);\n}","map":{"version":3,"names":["Point","Util","Transformation","a","b","c","d","isArray","_a","_b","_c","_d","prototype","transform","point","scale","_transform","clone","x","y","untransform","toTransformation"],"sources":["C:/Users/aless/OneDrive/Ãrea de Trabalho/Registro Ponto front-end GitHub/ReactProjects/my-app/node_modules/leaflet/src/geometry/Transformation.js"],"sourcesContent":["import {Point} from './Point';\r\nimport * as Util from '../core/Util';\r\n\r\n/*\r\n * @class Transformation\r\n * @aka L.Transformation\r\n *\r\n * Represents an affine transformation: a set of coefficients `a`, `b`, `c`, `d`\r\n * for transforming a point of a form `(x, y)` into `(a*x + b, c*y + d)` and doing\r\n * the reverse. Used by Leaflet in its projections code.\r\n *\r\n * @example\r\n *\r\n * ```js\r\n * var transformation = L.transformation(2, 5, -1, 10),\r\n * \tp = L.point(1, 2),\r\n * \tp2 = transformation.transform(p), //  L.point(7, 8)\r\n * \tp3 = transformation.untransform(p2); //  L.point(1, 2)\r\n * ```\r\n */\r\n\r\n\r\n// factory new L.Transformation(a: Number, b: Number, c: Number, d: Number)\r\n// Creates a `Transformation` object with the given coefficients.\r\nexport function Transformation(a, b, c, d) {\r\n\tif (Util.isArray(a)) {\r\n\t\t// use array properties\r\n\t\tthis._a = a[0];\r\n\t\tthis._b = a[1];\r\n\t\tthis._c = a[2];\r\n\t\tthis._d = a[3];\r\n\t\treturn;\r\n\t}\r\n\tthis._a = a;\r\n\tthis._b = b;\r\n\tthis._c = c;\r\n\tthis._d = d;\r\n}\r\n\r\nTransformation.prototype = {\r\n\t// @method transform(point: Point, scale?: Number): Point\r\n\t// Returns a transformed point, optionally multiplied by the given scale.\r\n\t// Only accepts actual `L.Point` instances, not arrays.\r\n\ttransform: function (point, scale) { // (Point, Number) -> Point\r\n\t\treturn this._transform(point.clone(), scale);\r\n\t},\r\n\r\n\t// destructive transform (faster)\r\n\t_transform: function (point, scale) {\r\n\t\tscale = scale || 1;\r\n\t\tpoint.x = scale * (this._a * point.x + this._b);\r\n\t\tpoint.y = scale * (this._c * point.y + this._d);\r\n\t\treturn point;\r\n\t},\r\n\r\n\t// @method untransform(point: Point, scale?: Number): Point\r\n\t// Returns the reverse transformation of the given point, optionally divided\r\n\t// by the given scale. Only accepts actual `L.Point` instances, not arrays.\r\n\tuntransform: function (point, scale) {\r\n\t\tscale = scale || 1;\r\n\t\treturn new Point(\r\n\t\t        (point.x / scale - this._b) / this._a,\r\n\t\t        (point.y / scale - this._d) / this._c);\r\n\t}\r\n};\r\n\r\n// factory L.transformation(a: Number, b: Number, c: Number, d: Number)\r\n\r\n// @factory L.transformation(a: Number, b: Number, c: Number, d: Number)\r\n// Instantiates a Transformation object with the given coefficients.\r\n\r\n// @alternative\r\n// @factory L.transformation(coefficients: Array): Transformation\r\n// Expects an coefficients array of the form\r\n// `[a: Number, b: Number, c: Number, d: Number]`.\r\n\r\nexport function toTransformation(a, b, c, d) {\r\n\treturn new Transformation(a, b, c, d);\r\n}\r\n"],"mappings":"AAAA,SAAQA,KAAK,QAAO,SAAS;AAC7B,OAAO,KAAKC,IAAI,MAAM,cAAc;;AAEpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA;AACA;AACA,OAAO,SAASC,cAAc,CAACC,CAAC,EAAEC,CAAC,EAAEC,CAAC,EAAEC,CAAC,EAAE;EAC1C,IAAIL,IAAI,CAACM,OAAO,CAACJ,CAAC,CAAC,EAAE;IACpB;IACA,IAAI,CAACK,EAAE,GAAGL,CAAC,CAAC,CAAC,CAAC;IACd,IAAI,CAACM,EAAE,GAAGN,CAAC,CAAC,CAAC,CAAC;IACd,IAAI,CAACO,EAAE,GAAGP,CAAC,CAAC,CAAC,CAAC;IACd,IAAI,CAACQ,EAAE,GAAGR,CAAC,CAAC,CAAC,CAAC;IACd;EACD;EACA,IAAI,CAACK,EAAE,GAAGL,CAAC;EACX,IAAI,CAACM,EAAE,GAAGL,CAAC;EACX,IAAI,CAACM,EAAE,GAAGL,CAAC;EACX,IAAI,CAACM,EAAE,GAAGL,CAAC;AACZ;AAEAJ,cAAc,CAACU,SAAS,GAAG;EAC1B;EACA;EACA;EACAC,SAAS,EAAE,UAAUC,KAAK,EAAEC,KAAK,EAAE;IAAE;IACpC,OAAO,IAAI,CAACC,UAAU,CAACF,KAAK,CAACG,KAAK,EAAE,EAAEF,KAAK,CAAC;EAC7C,CAAC;EAED;EACAC,UAAU,EAAE,UAAUF,KAAK,EAAEC,KAAK,EAAE;IACnCA,KAAK,GAAGA,KAAK,IAAI,CAAC;IAClBD,KAAK,CAACI,CAAC,GAAGH,KAAK,IAAI,IAAI,CAACP,EAAE,GAAGM,KAAK,CAACI,CAAC,GAAG,IAAI,CAACT,EAAE,CAAC;IAC/CK,KAAK,CAACK,CAAC,GAAGJ,KAAK,IAAI,IAAI,CAACL,EAAE,GAAGI,KAAK,CAACK,CAAC,GAAG,IAAI,CAACR,EAAE,CAAC;IAC/C,OAAOG,KAAK;EACb,CAAC;EAED;EACA;EACA;EACAM,WAAW,EAAE,UAAUN,KAAK,EAAEC,KAAK,EAAE;IACpCA,KAAK,GAAGA,KAAK,IAAI,CAAC;IAClB,OAAO,IAAIf,KAAK,CACR,CAACc,KAAK,CAACI,CAAC,GAAGH,KAAK,GAAG,IAAI,CAACN,EAAE,IAAI,IAAI,CAACD,EAAE,EACrC,CAACM,KAAK,CAACK,CAAC,GAAGJ,KAAK,GAAG,IAAI,CAACJ,EAAE,IAAI,IAAI,CAACD,EAAE,CAAC;EAC/C;AACD,CAAC;;AAED;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,OAAO,SAASW,gBAAgB,CAAClB,CAAC,EAAEC,CAAC,EAAEC,CAAC,EAAEC,CAAC,EAAE;EAC5C,OAAO,IAAIJ,cAAc,CAACC,CAAC,EAAEC,CAAC,EAAEC,CAAC,EAAEC,CAAC,CAAC;AACtC"},"metadata":{},"sourceType":"module","externalDependencies":[]}