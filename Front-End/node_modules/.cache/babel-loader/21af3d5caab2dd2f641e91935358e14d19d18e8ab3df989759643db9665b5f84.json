{"ast":null,"code":"import * as Util from '../core/Util';\nimport { Evented } from '../core/Events';\nimport { EPSG3857 } from '../geo/crs/CRS.EPSG3857';\nimport { Point, toPoint } from '../geometry/Point';\nimport { Bounds, toBounds } from '../geometry/Bounds';\nimport { LatLng, toLatLng } from '../geo/LatLng';\nimport { LatLngBounds, toLatLngBounds } from '../geo/LatLngBounds';\nimport Browser from '../core/Browser';\nimport * as DomEvent from '../dom/DomEvent';\nimport * as DomUtil from '../dom/DomUtil';\nimport { PosAnimation } from '../dom/PosAnimation';\n\n/*\r\n * @class Map\r\n * @aka L.Map\r\n * @inherits Evented\r\n *\r\n * The central class of the API — it is used to create a map on a page and manipulate it.\r\n *\r\n * @example\r\n *\r\n * ```js\r\n * // initialize the map on the \"map\" div with a given center and zoom\r\n * var map = L.map('map', {\r\n * \tcenter: [51.505, -0.09],\r\n * \tzoom: 13\r\n * });\r\n * ```\r\n *\r\n */\n\nexport var Map = Evented.extend({\n  options: {\n    // @section Map State Options\n    // @option crs: CRS = L.CRS.EPSG3857\n    // The [Coordinate Reference System](#crs) to use. Don't change this if you're not\n    // sure what it means.\n    crs: EPSG3857,\n    // @option center: LatLng = undefined\n    // Initial geographic center of the map\n    center: undefined,\n    // @option zoom: Number = undefined\n    // Initial map zoom level\n    zoom: undefined,\n    // @option minZoom: Number = *\n    // Minimum zoom level of the map.\n    // If not specified and at least one `GridLayer` or `TileLayer` is in the map,\n    // the lowest of their `minZoom` options will be used instead.\n    minZoom: undefined,\n    // @option maxZoom: Number = *\n    // Maximum zoom level of the map.\n    // If not specified and at least one `GridLayer` or `TileLayer` is in the map,\n    // the highest of their `maxZoom` options will be used instead.\n    maxZoom: undefined,\n    // @option layers: Layer[] = []\n    // Array of layers that will be added to the map initially\n    layers: [],\n    // @option maxBounds: LatLngBounds = null\n    // When this option is set, the map restricts the view to the given\n    // geographical bounds, bouncing the user back if the user tries to pan\n    // outside the view. To set the restriction dynamically, use\n    // [`setMaxBounds`](#map-setmaxbounds) method.\n    maxBounds: undefined,\n    // @option renderer: Renderer = *\n    // The default method for drawing vector layers on the map. `L.SVG`\n    // or `L.Canvas` by default depending on browser support.\n    renderer: undefined,\n    // @section Animation Options\n    // @option zoomAnimation: Boolean = true\n    // Whether the map zoom animation is enabled. By default it's enabled\n    // in all browsers that support CSS3 Transitions except Android.\n    zoomAnimation: true,\n    // @option zoomAnimationThreshold: Number = 4\n    // Won't animate zoom if the zoom difference exceeds this value.\n    zoomAnimationThreshold: 4,\n    // @option fadeAnimation: Boolean = true\n    // Whether the tile fade animation is enabled. By default it's enabled\n    // in all browsers that support CSS3 Transitions except Android.\n    fadeAnimation: true,\n    // @option markerZoomAnimation: Boolean = true\n    // Whether markers animate their zoom with the zoom animation, if disabled\n    // they will disappear for the length of the animation. By default it's\n    // enabled in all browsers that support CSS3 Transitions except Android.\n    markerZoomAnimation: true,\n    // @option transform3DLimit: Number = 2^23\n    // Defines the maximum size of a CSS translation transform. The default\n    // value should not be changed unless a web browser positions layers in\n    // the wrong place after doing a large `panBy`.\n    transform3DLimit: 8388608,\n    // Precision limit of a 32-bit float\n\n    // @section Interaction Options\n    // @option zoomSnap: Number = 1\n    // Forces the map's zoom level to always be a multiple of this, particularly\n    // right after a [`fitBounds()`](#map-fitbounds) or a pinch-zoom.\n    // By default, the zoom level snaps to the nearest integer; lower values\n    // (e.g. `0.5` or `0.1`) allow for greater granularity. A value of `0`\n    // means the zoom level will not be snapped after `fitBounds` or a pinch-zoom.\n    zoomSnap: 1,\n    // @option zoomDelta: Number = 1\n    // Controls how much the map's zoom level will change after a\n    // [`zoomIn()`](#map-zoomin), [`zoomOut()`](#map-zoomout), pressing `+`\n    // or `-` on the keyboard, or using the [zoom controls](#control-zoom).\n    // Values smaller than `1` (e.g. `0.5`) allow for greater granularity.\n    zoomDelta: 1,\n    // @option trackResize: Boolean = true\n    // Whether the map automatically handles browser window resize to update itself.\n    trackResize: true\n  },\n  initialize: function (id, options) {\n    // (HTMLElement or String, Object)\n    options = Util.setOptions(this, options);\n\n    // Make sure to assign internal flags at the beginning,\n    // to avoid inconsistent state in some edge cases.\n    this._handlers = [];\n    this._layers = {};\n    this._zoomBoundLayers = {};\n    this._sizeChanged = true;\n    this._initContainer(id);\n    this._initLayout();\n\n    // hack for https://github.com/Leaflet/Leaflet/issues/1980\n    this._onResize = Util.bind(this._onResize, this);\n    this._initEvents();\n    if (options.maxBounds) {\n      this.setMaxBounds(options.maxBounds);\n    }\n    if (options.zoom !== undefined) {\n      this._zoom = this._limitZoom(options.zoom);\n    }\n    if (options.center && options.zoom !== undefined) {\n      this.setView(toLatLng(options.center), options.zoom, {\n        reset: true\n      });\n    }\n    this.callInitHooks();\n\n    // don't animate on browsers without hardware-accelerated transitions or old Android/Opera\n    this._zoomAnimated = DomUtil.TRANSITION && Browser.any3d && !Browser.mobileOpera && this.options.zoomAnimation;\n\n    // zoom transitions run with the same duration for all layers, so if one of transitionend events\n    // happens after starting zoom animation (propagating to the map pane), we know that it ended globally\n    if (this._zoomAnimated) {\n      this._createAnimProxy();\n      DomEvent.on(this._proxy, DomUtil.TRANSITION_END, this._catchTransitionEnd, this);\n    }\n    this._addLayers(this.options.layers);\n  },\n  // @section Methods for modifying map state\n\n  // @method setView(center: LatLng, zoom: Number, options?: Zoom/pan options): this\n  // Sets the view of the map (geographical center and zoom) with the given\n  // animation options.\n  setView: function (center, zoom, options) {\n    zoom = zoom === undefined ? this._zoom : this._limitZoom(zoom);\n    center = this._limitCenter(toLatLng(center), zoom, this.options.maxBounds);\n    options = options || {};\n    this._stop();\n    if (this._loaded && !options.reset && options !== true) {\n      if (options.animate !== undefined) {\n        options.zoom = Util.extend({\n          animate: options.animate\n        }, options.zoom);\n        options.pan = Util.extend({\n          animate: options.animate,\n          duration: options.duration\n        }, options.pan);\n      }\n\n      // try animating pan or zoom\n      var moved = this._zoom !== zoom ? this._tryAnimatedZoom && this._tryAnimatedZoom(center, zoom, options.zoom) : this._tryAnimatedPan(center, options.pan);\n      if (moved) {\n        // prevent resize handler call, the view will refresh after animation anyway\n        clearTimeout(this._sizeTimer);\n        return this;\n      }\n    }\n\n    // animation didn't start, just reset the map view\n    this._resetView(center, zoom, options.pan && options.pan.noMoveStart);\n    return this;\n  },\n  // @method setZoom(zoom: Number, options?: Zoom/pan options): this\n  // Sets the zoom of the map.\n  setZoom: function (zoom, options) {\n    if (!this._loaded) {\n      this._zoom = zoom;\n      return this;\n    }\n    return this.setView(this.getCenter(), zoom, {\n      zoom: options\n    });\n  },\n  // @method zoomIn(delta?: Number, options?: Zoom options): this\n  // Increases the zoom of the map by `delta` ([`zoomDelta`](#map-zoomdelta) by default).\n  zoomIn: function (delta, options) {\n    delta = delta || (Browser.any3d ? this.options.zoomDelta : 1);\n    return this.setZoom(this._zoom + delta, options);\n  },\n  // @method zoomOut(delta?: Number, options?: Zoom options): this\n  // Decreases the zoom of the map by `delta` ([`zoomDelta`](#map-zoomdelta) by default).\n  zoomOut: function (delta, options) {\n    delta = delta || (Browser.any3d ? this.options.zoomDelta : 1);\n    return this.setZoom(this._zoom - delta, options);\n  },\n  // @method setZoomAround(latlng: LatLng, zoom: Number, options: Zoom options): this\n  // Zooms the map while keeping a specified geographical point on the map\n  // stationary (e.g. used internally for scroll zoom and double-click zoom).\n  // @alternative\n  // @method setZoomAround(offset: Point, zoom: Number, options: Zoom options): this\n  // Zooms the map while keeping a specified pixel on the map (relative to the top-left corner) stationary.\n  setZoomAround: function (latlng, zoom, options) {\n    var scale = this.getZoomScale(zoom),\n      viewHalf = this.getSize().divideBy(2),\n      containerPoint = latlng instanceof Point ? latlng : this.latLngToContainerPoint(latlng),\n      centerOffset = containerPoint.subtract(viewHalf).multiplyBy(1 - 1 / scale),\n      newCenter = this.containerPointToLatLng(viewHalf.add(centerOffset));\n    return this.setView(newCenter, zoom, {\n      zoom: options\n    });\n  },\n  _getBoundsCenterZoom: function (bounds, options) {\n    options = options || {};\n    bounds = bounds.getBounds ? bounds.getBounds() : toLatLngBounds(bounds);\n    var paddingTL = toPoint(options.paddingTopLeft || options.padding || [0, 0]),\n      paddingBR = toPoint(options.paddingBottomRight || options.padding || [0, 0]),\n      zoom = this.getBoundsZoom(bounds, false, paddingTL.add(paddingBR));\n    zoom = typeof options.maxZoom === 'number' ? Math.min(options.maxZoom, zoom) : zoom;\n    if (zoom === Infinity) {\n      return {\n        center: bounds.getCenter(),\n        zoom: zoom\n      };\n    }\n    var paddingOffset = paddingBR.subtract(paddingTL).divideBy(2),\n      swPoint = this.project(bounds.getSouthWest(), zoom),\n      nePoint = this.project(bounds.getNorthEast(), zoom),\n      center = this.unproject(swPoint.add(nePoint).divideBy(2).add(paddingOffset), zoom);\n    return {\n      center: center,\n      zoom: zoom\n    };\n  },\n  // @method fitBounds(bounds: LatLngBounds, options?: fitBounds options): this\n  // Sets a map view that contains the given geographical bounds with the\n  // maximum zoom level possible.\n  fitBounds: function (bounds, options) {\n    bounds = toLatLngBounds(bounds);\n    if (!bounds.isValid()) {\n      throw new Error('Bounds are not valid.');\n    }\n    var target = this._getBoundsCenterZoom(bounds, options);\n    return this.setView(target.center, target.zoom, options);\n  },\n  // @method fitWorld(options?: fitBounds options): this\n  // Sets a map view that mostly contains the whole world with the maximum\n  // zoom level possible.\n  fitWorld: function (options) {\n    return this.fitBounds([[-90, -180], [90, 180]], options);\n  },\n  // @method panTo(latlng: LatLng, options?: Pan options): this\n  // Pans the map to a given center.\n  panTo: function (center, options) {\n    // (LatLng)\n    return this.setView(center, this._zoom, {\n      pan: options\n    });\n  },\n  // @method panBy(offset: Point, options?: Pan options): this\n  // Pans the map by a given number of pixels (animated).\n  panBy: function (offset, options) {\n    offset = toPoint(offset).round();\n    options = options || {};\n    if (!offset.x && !offset.y) {\n      return this.fire('moveend');\n    }\n    // If we pan too far, Chrome gets issues with tiles\n    // and makes them disappear or appear in the wrong place (slightly offset) #2602\n    if (options.animate !== true && !this.getSize().contains(offset)) {\n      this._resetView(this.unproject(this.project(this.getCenter()).add(offset)), this.getZoom());\n      return this;\n    }\n    if (!this._panAnim) {\n      this._panAnim = new PosAnimation();\n      this._panAnim.on({\n        'step': this._onPanTransitionStep,\n        'end': this._onPanTransitionEnd\n      }, this);\n    }\n\n    // don't fire movestart if animating inertia\n    if (!options.noMoveStart) {\n      this.fire('movestart');\n    }\n\n    // animate pan unless animate: false specified\n    if (options.animate !== false) {\n      DomUtil.addClass(this._mapPane, 'leaflet-pan-anim');\n      var newPos = this._getMapPanePos().subtract(offset).round();\n      this._panAnim.run(this._mapPane, newPos, options.duration || 0.25, options.easeLinearity);\n    } else {\n      this._rawPanBy(offset);\n      this.fire('move').fire('moveend');\n    }\n    return this;\n  },\n  // @method flyTo(latlng: LatLng, zoom?: Number, options?: Zoom/pan options): this\n  // Sets the view of the map (geographical center and zoom) performing a smooth\n  // pan-zoom animation.\n  flyTo: function (targetCenter, targetZoom, options) {\n    options = options || {};\n    if (options.animate === false || !Browser.any3d) {\n      return this.setView(targetCenter, targetZoom, options);\n    }\n    this._stop();\n    var from = this.project(this.getCenter()),\n      to = this.project(targetCenter),\n      size = this.getSize(),\n      startZoom = this._zoom;\n    targetCenter = toLatLng(targetCenter);\n    targetZoom = targetZoom === undefined ? startZoom : targetZoom;\n    var w0 = Math.max(size.x, size.y),\n      w1 = w0 * this.getZoomScale(startZoom, targetZoom),\n      u1 = to.distanceTo(from) || 1,\n      rho = 1.42,\n      rho2 = rho * rho;\n    function r(i) {\n      var s1 = i ? -1 : 1,\n        s2 = i ? w1 : w0,\n        t1 = w1 * w1 - w0 * w0 + s1 * rho2 * rho2 * u1 * u1,\n        b1 = 2 * s2 * rho2 * u1,\n        b = t1 / b1,\n        sq = Math.sqrt(b * b + 1) - b;\n\n      // workaround for floating point precision bug when sq = 0, log = -Infinite,\n      // thus triggering an infinite loop in flyTo\n      var log = sq < 0.000000001 ? -18 : Math.log(sq);\n      return log;\n    }\n    function sinh(n) {\n      return (Math.exp(n) - Math.exp(-n)) / 2;\n    }\n    function cosh(n) {\n      return (Math.exp(n) + Math.exp(-n)) / 2;\n    }\n    function tanh(n) {\n      return sinh(n) / cosh(n);\n    }\n    var r0 = r(0);\n    function w(s) {\n      return w0 * (cosh(r0) / cosh(r0 + rho * s));\n    }\n    function u(s) {\n      return w0 * (cosh(r0) * tanh(r0 + rho * s) - sinh(r0)) / rho2;\n    }\n    function easeOut(t) {\n      return 1 - Math.pow(1 - t, 1.5);\n    }\n    var start = Date.now(),\n      S = (r(1) - r0) / rho,\n      duration = options.duration ? 1000 * options.duration : 1000 * S * 0.8;\n    function frame() {\n      var t = (Date.now() - start) / duration,\n        s = easeOut(t) * S;\n      if (t <= 1) {\n        this._flyToFrame = Util.requestAnimFrame(frame, this);\n        this._move(this.unproject(from.add(to.subtract(from).multiplyBy(u(s) / u1)), startZoom), this.getScaleZoom(w0 / w(s), startZoom), {\n          flyTo: true\n        });\n      } else {\n        this._move(targetCenter, targetZoom)._moveEnd(true);\n      }\n    }\n    this._moveStart(true, options.noMoveStart);\n    frame.call(this);\n    return this;\n  },\n  // @method flyToBounds(bounds: LatLngBounds, options?: fitBounds options): this\n  // Sets the view of the map with a smooth animation like [`flyTo`](#map-flyto),\n  // but takes a bounds parameter like [`fitBounds`](#map-fitbounds).\n  flyToBounds: function (bounds, options) {\n    var target = this._getBoundsCenterZoom(bounds, options);\n    return this.flyTo(target.center, target.zoom, options);\n  },\n  // @method setMaxBounds(bounds: LatLngBounds): this\n  // Restricts the map view to the given bounds (see the [maxBounds](#map-maxbounds) option).\n  setMaxBounds: function (bounds) {\n    bounds = toLatLngBounds(bounds);\n    if (this.listens('moveend', this._panInsideMaxBounds)) {\n      this.off('moveend', this._panInsideMaxBounds);\n    }\n    if (!bounds.isValid()) {\n      this.options.maxBounds = null;\n      return this;\n    }\n    this.options.maxBounds = bounds;\n    if (this._loaded) {\n      this._panInsideMaxBounds();\n    }\n    return this.on('moveend', this._panInsideMaxBounds);\n  },\n  // @method setMinZoom(zoom: Number): this\n  // Sets the lower limit for the available zoom levels (see the [minZoom](#map-minzoom) option).\n  setMinZoom: function (zoom) {\n    var oldZoom = this.options.minZoom;\n    this.options.minZoom = zoom;\n    if (this._loaded && oldZoom !== zoom) {\n      this.fire('zoomlevelschange');\n      if (this.getZoom() < this.options.minZoom) {\n        return this.setZoom(zoom);\n      }\n    }\n    return this;\n  },\n  // @method setMaxZoom(zoom: Number): this\n  // Sets the upper limit for the available zoom levels (see the [maxZoom](#map-maxzoom) option).\n  setMaxZoom: function (zoom) {\n    var oldZoom = this.options.maxZoom;\n    this.options.maxZoom = zoom;\n    if (this._loaded && oldZoom !== zoom) {\n      this.fire('zoomlevelschange');\n      if (this.getZoom() > this.options.maxZoom) {\n        return this.setZoom(zoom);\n      }\n    }\n    return this;\n  },\n  // @method panInsideBounds(bounds: LatLngBounds, options?: Pan options): this\n  // Pans the map to the closest view that would lie inside the given bounds (if it's not already), controlling the animation using the options specific, if any.\n  panInsideBounds: function (bounds, options) {\n    this._enforcingBounds = true;\n    var center = this.getCenter(),\n      newCenter = this._limitCenter(center, this._zoom, toLatLngBounds(bounds));\n    if (!center.equals(newCenter)) {\n      this.panTo(newCenter, options);\n    }\n    this._enforcingBounds = false;\n    return this;\n  },\n  // @method panInside(latlng: LatLng, options?: padding options): this\n  // Pans the map the minimum amount to make the `latlng` visible. Use\n  // padding options to fit the display to more restricted bounds.\n  // If `latlng` is already within the (optionally padded) display bounds,\n  // the map will not be panned.\n  panInside: function (latlng, options) {\n    options = options || {};\n    var paddingTL = toPoint(options.paddingTopLeft || options.padding || [0, 0]),\n      paddingBR = toPoint(options.paddingBottomRight || options.padding || [0, 0]),\n      pixelCenter = this.project(this.getCenter()),\n      pixelPoint = this.project(latlng),\n      pixelBounds = this.getPixelBounds(),\n      paddedBounds = toBounds([pixelBounds.min.add(paddingTL), pixelBounds.max.subtract(paddingBR)]),\n      paddedSize = paddedBounds.getSize();\n    if (!paddedBounds.contains(pixelPoint)) {\n      this._enforcingBounds = true;\n      var centerOffset = pixelPoint.subtract(paddedBounds.getCenter());\n      var offset = paddedBounds.extend(pixelPoint).getSize().subtract(paddedSize);\n      pixelCenter.x += centerOffset.x < 0 ? -offset.x : offset.x;\n      pixelCenter.y += centerOffset.y < 0 ? -offset.y : offset.y;\n      this.panTo(this.unproject(pixelCenter), options);\n      this._enforcingBounds = false;\n    }\n    return this;\n  },\n  // @method invalidateSize(options: Zoom/pan options): this\n  // Checks if the map container size changed and updates the map if so —\n  // call it after you've changed the map size dynamically, also animating\n  // pan by default. If `options.pan` is `false`, panning will not occur.\n  // If `options.debounceMoveend` is `true`, it will delay `moveend` event so\n  // that it doesn't happen often even if the method is called many\n  // times in a row.\n\n  // @alternative\n  // @method invalidateSize(animate: Boolean): this\n  // Checks if the map container size changed and updates the map if so —\n  // call it after you've changed the map size dynamically, also animating\n  // pan by default.\n  invalidateSize: function (options) {\n    if (!this._loaded) {\n      return this;\n    }\n    options = Util.extend({\n      animate: false,\n      pan: true\n    }, options === true ? {\n      animate: true\n    } : options);\n    var oldSize = this.getSize();\n    this._sizeChanged = true;\n    this._lastCenter = null;\n    var newSize = this.getSize(),\n      oldCenter = oldSize.divideBy(2).round(),\n      newCenter = newSize.divideBy(2).round(),\n      offset = oldCenter.subtract(newCenter);\n    if (!offset.x && !offset.y) {\n      return this;\n    }\n    if (options.animate && options.pan) {\n      this.panBy(offset);\n    } else {\n      if (options.pan) {\n        this._rawPanBy(offset);\n      }\n      this.fire('move');\n      if (options.debounceMoveend) {\n        clearTimeout(this._sizeTimer);\n        this._sizeTimer = setTimeout(Util.bind(this.fire, this, 'moveend'), 200);\n      } else {\n        this.fire('moveend');\n      }\n    }\n\n    // @section Map state change events\n    // @event resize: ResizeEvent\n    // Fired when the map is resized.\n    return this.fire('resize', {\n      oldSize: oldSize,\n      newSize: newSize\n    });\n  },\n  // @section Methods for modifying map state\n  // @method stop(): this\n  // Stops the currently running `panTo` or `flyTo` animation, if any.\n  stop: function () {\n    this.setZoom(this._limitZoom(this._zoom));\n    if (!this.options.zoomSnap) {\n      this.fire('viewreset');\n    }\n    return this._stop();\n  },\n  // @section Geolocation methods\n  // @method locate(options?: Locate options): this\n  // Tries to locate the user using the Geolocation API, firing a [`locationfound`](#map-locationfound)\n  // event with location data on success or a [`locationerror`](#map-locationerror) event on failure,\n  // and optionally sets the map view to the user's location with respect to\n  // detection accuracy (or to the world view if geolocation failed).\n  // Note that, if your page doesn't use HTTPS, this method will fail in\n  // modern browsers ([Chrome 50 and newer](https://sites.google.com/a/chromium.org/dev/Home/chromium-security/deprecating-powerful-features-on-insecure-origins))\n  // See `Locate options` for more details.\n  locate: function (options) {\n    options = this._locateOptions = Util.extend({\n      timeout: 10000,\n      watch: false\n      // setView: false\n      // maxZoom: <Number>\n      // maximumAge: 0\n      // enableHighAccuracy: false\n    }, options);\n    if (!('geolocation' in navigator)) {\n      this._handleGeolocationError({\n        code: 0,\n        message: 'Geolocation not supported.'\n      });\n      return this;\n    }\n    var onResponse = Util.bind(this._handleGeolocationResponse, this),\n      onError = Util.bind(this._handleGeolocationError, this);\n    if (options.watch) {\n      this._locationWatchId = navigator.geolocation.watchPosition(onResponse, onError, options);\n    } else {\n      navigator.geolocation.getCurrentPosition(onResponse, onError, options);\n    }\n    return this;\n  },\n  // @method stopLocate(): this\n  // Stops watching location previously initiated by `map.locate({watch: true})`\n  // and aborts resetting the map view if map.locate was called with\n  // `{setView: true}`.\n  stopLocate: function () {\n    if (navigator.geolocation && navigator.geolocation.clearWatch) {\n      navigator.geolocation.clearWatch(this._locationWatchId);\n    }\n    if (this._locateOptions) {\n      this._locateOptions.setView = false;\n    }\n    return this;\n  },\n  _handleGeolocationError: function (error) {\n    if (!this._container._leaflet_id) {\n      return;\n    }\n    var c = error.code,\n      message = error.message || (c === 1 ? 'permission denied' : c === 2 ? 'position unavailable' : 'timeout');\n    if (this._locateOptions.setView && !this._loaded) {\n      this.fitWorld();\n    }\n\n    // @section Location events\n    // @event locationerror: ErrorEvent\n    // Fired when geolocation (using the [`locate`](#map-locate) method) failed.\n    this.fire('locationerror', {\n      code: c,\n      message: 'Geolocation error: ' + message + '.'\n    });\n  },\n  _handleGeolocationResponse: function (pos) {\n    if (!this._container._leaflet_id) {\n      return;\n    }\n    var lat = pos.coords.latitude,\n      lng = pos.coords.longitude,\n      latlng = new LatLng(lat, lng),\n      bounds = latlng.toBounds(pos.coords.accuracy * 2),\n      options = this._locateOptions;\n    if (options.setView) {\n      var zoom = this.getBoundsZoom(bounds);\n      this.setView(latlng, options.maxZoom ? Math.min(zoom, options.maxZoom) : zoom);\n    }\n    var data = {\n      latlng: latlng,\n      bounds: bounds,\n      timestamp: pos.timestamp\n    };\n    for (var i in pos.coords) {\n      if (typeof pos.coords[i] === 'number') {\n        data[i] = pos.coords[i];\n      }\n    }\n\n    // @event locationfound: LocationEvent\n    // Fired when geolocation (using the [`locate`](#map-locate) method)\n    // went successfully.\n    this.fire('locationfound', data);\n  },\n  // TODO Appropriate docs section?\n  // @section Other Methods\n  // @method addHandler(name: String, HandlerClass: Function): this\n  // Adds a new `Handler` to the map, given its name and constructor function.\n  addHandler: function (name, HandlerClass) {\n    if (!HandlerClass) {\n      return this;\n    }\n    var handler = this[name] = new HandlerClass(this);\n    this._handlers.push(handler);\n    if (this.options[name]) {\n      handler.enable();\n    }\n    return this;\n  },\n  // @method remove(): this\n  // Destroys the map and clears all related event listeners.\n  remove: function () {\n    this._initEvents(true);\n    if (this.options.maxBounds) {\n      this.off('moveend', this._panInsideMaxBounds);\n    }\n    if (this._containerId !== this._container._leaflet_id) {\n      throw new Error('Map container is being reused by another instance');\n    }\n    try {\n      // throws error in IE6-8\n      delete this._container._leaflet_id;\n      delete this._containerId;\n    } catch (e) {\n      /*eslint-disable */\n      this._container._leaflet_id = undefined;\n      /* eslint-enable */\n      this._containerId = undefined;\n    }\n    if (this._locationWatchId !== undefined) {\n      this.stopLocate();\n    }\n    this._stop();\n    DomUtil.remove(this._mapPane);\n    if (this._clearControlPos) {\n      this._clearControlPos();\n    }\n    if (this._resizeRequest) {\n      Util.cancelAnimFrame(this._resizeRequest);\n      this._resizeRequest = null;\n    }\n    this._clearHandlers();\n    if (this._loaded) {\n      // @section Map state change events\n      // @event unload: Event\n      // Fired when the map is destroyed with [remove](#map-remove) method.\n      this.fire('unload');\n    }\n    var i;\n    for (i in this._layers) {\n      this._layers[i].remove();\n    }\n    for (i in this._panes) {\n      DomUtil.remove(this._panes[i]);\n    }\n    this._layers = [];\n    this._panes = [];\n    delete this._mapPane;\n    delete this._renderer;\n    return this;\n  },\n  // @section Other Methods\n  // @method createPane(name: String, container?: HTMLElement): HTMLElement\n  // Creates a new [map pane](#map-pane) with the given name if it doesn't exist already,\n  // then returns it. The pane is created as a child of `container`, or\n  // as a child of the main map pane if not set.\n  createPane: function (name, container) {\n    var className = 'leaflet-pane' + (name ? ' leaflet-' + name.replace('Pane', '') + '-pane' : ''),\n      pane = DomUtil.create('div', className, container || this._mapPane);\n    if (name) {\n      this._panes[name] = pane;\n    }\n    return pane;\n  },\n  // @section Methods for Getting Map State\n\n  // @method getCenter(): LatLng\n  // Returns the geographical center of the map view\n  getCenter: function () {\n    this._checkIfLoaded();\n    if (this._lastCenter && !this._moved()) {\n      return this._lastCenter.clone();\n    }\n    return this.layerPointToLatLng(this._getCenterLayerPoint());\n  },\n  // @method getZoom(): Number\n  // Returns the current zoom level of the map view\n  getZoom: function () {\n    return this._zoom;\n  },\n  // @method getBounds(): LatLngBounds\n  // Returns the geographical bounds visible in the current map view\n  getBounds: function () {\n    var bounds = this.getPixelBounds(),\n      sw = this.unproject(bounds.getBottomLeft()),\n      ne = this.unproject(bounds.getTopRight());\n    return new LatLngBounds(sw, ne);\n  },\n  // @method getMinZoom(): Number\n  // Returns the minimum zoom level of the map (if set in the `minZoom` option of the map or of any layers), or `0` by default.\n  getMinZoom: function () {\n    return this.options.minZoom === undefined ? this._layersMinZoom || 0 : this.options.minZoom;\n  },\n  // @method getMaxZoom(): Number\n  // Returns the maximum zoom level of the map (if set in the `maxZoom` option of the map or of any layers).\n  getMaxZoom: function () {\n    return this.options.maxZoom === undefined ? this._layersMaxZoom === undefined ? Infinity : this._layersMaxZoom : this.options.maxZoom;\n  },\n  // @method getBoundsZoom(bounds: LatLngBounds, inside?: Boolean, padding?: Point): Number\n  // Returns the maximum zoom level on which the given bounds fit to the map\n  // view in its entirety. If `inside` (optional) is set to `true`, the method\n  // instead returns the minimum zoom level on which the map view fits into\n  // the given bounds in its entirety.\n  getBoundsZoom: function (bounds, inside, padding) {\n    // (LatLngBounds[, Boolean, Point]) -> Number\n    bounds = toLatLngBounds(bounds);\n    padding = toPoint(padding || [0, 0]);\n    var zoom = this.getZoom() || 0,\n      min = this.getMinZoom(),\n      max = this.getMaxZoom(),\n      nw = bounds.getNorthWest(),\n      se = bounds.getSouthEast(),\n      size = this.getSize().subtract(padding),\n      boundsSize = toBounds(this.project(se, zoom), this.project(nw, zoom)).getSize(),\n      snap = Browser.any3d ? this.options.zoomSnap : 1,\n      scalex = size.x / boundsSize.x,\n      scaley = size.y / boundsSize.y,\n      scale = inside ? Math.max(scalex, scaley) : Math.min(scalex, scaley);\n    zoom = this.getScaleZoom(scale, zoom);\n    if (snap) {\n      zoom = Math.round(zoom / (snap / 100)) * (snap / 100); // don't jump if within 1% of a snap level\n      zoom = inside ? Math.ceil(zoom / snap) * snap : Math.floor(zoom / snap) * snap;\n    }\n    return Math.max(min, Math.min(max, zoom));\n  },\n  // @method getSize(): Point\n  // Returns the current size of the map container (in pixels).\n  getSize: function () {\n    if (!this._size || this._sizeChanged) {\n      this._size = new Point(this._container.clientWidth || 0, this._container.clientHeight || 0);\n      this._sizeChanged = false;\n    }\n    return this._size.clone();\n  },\n  // @method getPixelBounds(): Bounds\n  // Returns the bounds of the current map view in projected pixel\n  // coordinates (sometimes useful in layer and overlay implementations).\n  getPixelBounds: function (center, zoom) {\n    var topLeftPoint = this._getTopLeftPoint(center, zoom);\n    return new Bounds(topLeftPoint, topLeftPoint.add(this.getSize()));\n  },\n  // TODO: Check semantics - isn't the pixel origin the 0,0 coord relative to\n  // the map pane? \"left point of the map layer\" can be confusing, specially\n  // since there can be negative offsets.\n  // @method getPixelOrigin(): Point\n  // Returns the projected pixel coordinates of the top left point of\n  // the map layer (useful in custom layer and overlay implementations).\n  getPixelOrigin: function () {\n    this._checkIfLoaded();\n    return this._pixelOrigin;\n  },\n  // @method getPixelWorldBounds(zoom?: Number): Bounds\n  // Returns the world's bounds in pixel coordinates for zoom level `zoom`.\n  // If `zoom` is omitted, the map's current zoom level is used.\n  getPixelWorldBounds: function (zoom) {\n    return this.options.crs.getProjectedBounds(zoom === undefined ? this.getZoom() : zoom);\n  },\n  // @section Other Methods\n\n  // @method getPane(pane: String|HTMLElement): HTMLElement\n  // Returns a [map pane](#map-pane), given its name or its HTML element (its identity).\n  getPane: function (pane) {\n    return typeof pane === 'string' ? this._panes[pane] : pane;\n  },\n  // @method getPanes(): Object\n  // Returns a plain object containing the names of all [panes](#map-pane) as keys and\n  // the panes as values.\n  getPanes: function () {\n    return this._panes;\n  },\n  // @method getContainer: HTMLElement\n  // Returns the HTML element that contains the map.\n  getContainer: function () {\n    return this._container;\n  },\n  // @section Conversion Methods\n\n  // @method getZoomScale(toZoom: Number, fromZoom: Number): Number\n  // Returns the scale factor to be applied to a map transition from zoom level\n  // `fromZoom` to `toZoom`. Used internally to help with zoom animations.\n  getZoomScale: function (toZoom, fromZoom) {\n    // TODO replace with universal implementation after refactoring projections\n    var crs = this.options.crs;\n    fromZoom = fromZoom === undefined ? this._zoom : fromZoom;\n    return crs.scale(toZoom) / crs.scale(fromZoom);\n  },\n  // @method getScaleZoom(scale: Number, fromZoom: Number): Number\n  // Returns the zoom level that the map would end up at, if it is at `fromZoom`\n  // level and everything is scaled by a factor of `scale`. Inverse of\n  // [`getZoomScale`](#map-getZoomScale).\n  getScaleZoom: function (scale, fromZoom) {\n    var crs = this.options.crs;\n    fromZoom = fromZoom === undefined ? this._zoom : fromZoom;\n    var zoom = crs.zoom(scale * crs.scale(fromZoom));\n    return isNaN(zoom) ? Infinity : zoom;\n  },\n  // @method project(latlng: LatLng, zoom: Number): Point\n  // Projects a geographical coordinate `LatLng` according to the projection\n  // of the map's CRS, then scales it according to `zoom` and the CRS's\n  // `Transformation`. The result is pixel coordinate relative to\n  // the CRS origin.\n  project: function (latlng, zoom) {\n    zoom = zoom === undefined ? this._zoom : zoom;\n    return this.options.crs.latLngToPoint(toLatLng(latlng), zoom);\n  },\n  // @method unproject(point: Point, zoom: Number): LatLng\n  // Inverse of [`project`](#map-project).\n  unproject: function (point, zoom) {\n    zoom = zoom === undefined ? this._zoom : zoom;\n    return this.options.crs.pointToLatLng(toPoint(point), zoom);\n  },\n  // @method layerPointToLatLng(point: Point): LatLng\n  // Given a pixel coordinate relative to the [origin pixel](#map-getpixelorigin),\n  // returns the corresponding geographical coordinate (for the current zoom level).\n  layerPointToLatLng: function (point) {\n    var projectedPoint = toPoint(point).add(this.getPixelOrigin());\n    return this.unproject(projectedPoint);\n  },\n  // @method latLngToLayerPoint(latlng: LatLng): Point\n  // Given a geographical coordinate, returns the corresponding pixel coordinate\n  // relative to the [origin pixel](#map-getpixelorigin).\n  latLngToLayerPoint: function (latlng) {\n    var projectedPoint = this.project(toLatLng(latlng))._round();\n    return projectedPoint._subtract(this.getPixelOrigin());\n  },\n  // @method wrapLatLng(latlng: LatLng): LatLng\n  // Returns a `LatLng` where `lat` and `lng` has been wrapped according to the\n  // map's CRS's `wrapLat` and `wrapLng` properties, if they are outside the\n  // CRS's bounds.\n  // By default this means longitude is wrapped around the dateline so its\n  // value is between -180 and +180 degrees.\n  wrapLatLng: function (latlng) {\n    return this.options.crs.wrapLatLng(toLatLng(latlng));\n  },\n  // @method wrapLatLngBounds(bounds: LatLngBounds): LatLngBounds\n  // Returns a `LatLngBounds` with the same size as the given one, ensuring that\n  // its center is within the CRS's bounds.\n  // By default this means the center longitude is wrapped around the dateline so its\n  // value is between -180 and +180 degrees, and the majority of the bounds\n  // overlaps the CRS's bounds.\n  wrapLatLngBounds: function (latlng) {\n    return this.options.crs.wrapLatLngBounds(toLatLngBounds(latlng));\n  },\n  // @method distance(latlng1: LatLng, latlng2: LatLng): Number\n  // Returns the distance between two geographical coordinates according to\n  // the map's CRS. By default this measures distance in meters.\n  distance: function (latlng1, latlng2) {\n    return this.options.crs.distance(toLatLng(latlng1), toLatLng(latlng2));\n  },\n  // @method containerPointToLayerPoint(point: Point): Point\n  // Given a pixel coordinate relative to the map container, returns the corresponding\n  // pixel coordinate relative to the [origin pixel](#map-getpixelorigin).\n  containerPointToLayerPoint: function (point) {\n    // (Point)\n    return toPoint(point).subtract(this._getMapPanePos());\n  },\n  // @method layerPointToContainerPoint(point: Point): Point\n  // Given a pixel coordinate relative to the [origin pixel](#map-getpixelorigin),\n  // returns the corresponding pixel coordinate relative to the map container.\n  layerPointToContainerPoint: function (point) {\n    // (Point)\n    return toPoint(point).add(this._getMapPanePos());\n  },\n  // @method containerPointToLatLng(point: Point): LatLng\n  // Given a pixel coordinate relative to the map container, returns\n  // the corresponding geographical coordinate (for the current zoom level).\n  containerPointToLatLng: function (point) {\n    var layerPoint = this.containerPointToLayerPoint(toPoint(point));\n    return this.layerPointToLatLng(layerPoint);\n  },\n  // @method latLngToContainerPoint(latlng: LatLng): Point\n  // Given a geographical coordinate, returns the corresponding pixel coordinate\n  // relative to the map container.\n  latLngToContainerPoint: function (latlng) {\n    return this.layerPointToContainerPoint(this.latLngToLayerPoint(toLatLng(latlng)));\n  },\n  // @method mouseEventToContainerPoint(ev: MouseEvent): Point\n  // Given a MouseEvent object, returns the pixel coordinate relative to the\n  // map container where the event took place.\n  mouseEventToContainerPoint: function (e) {\n    return DomEvent.getMousePosition(e, this._container);\n  },\n  // @method mouseEventToLayerPoint(ev: MouseEvent): Point\n  // Given a MouseEvent object, returns the pixel coordinate relative to\n  // the [origin pixel](#map-getpixelorigin) where the event took place.\n  mouseEventToLayerPoint: function (e) {\n    return this.containerPointToLayerPoint(this.mouseEventToContainerPoint(e));\n  },\n  // @method mouseEventToLatLng(ev: MouseEvent): LatLng\n  // Given a MouseEvent object, returns geographical coordinate where the\n  // event took place.\n  mouseEventToLatLng: function (e) {\n    // (MouseEvent)\n    return this.layerPointToLatLng(this.mouseEventToLayerPoint(e));\n  },\n  // map initialization methods\n\n  _initContainer: function (id) {\n    var container = this._container = DomUtil.get(id);\n    if (!container) {\n      throw new Error('Map container not found.');\n    } else if (container._leaflet_id) {\n      throw new Error('Map container is already initialized.');\n    }\n    DomEvent.on(container, 'scroll', this._onScroll, this);\n    this._containerId = Util.stamp(container);\n  },\n  _initLayout: function () {\n    var container = this._container;\n    this._fadeAnimated = this.options.fadeAnimation && Browser.any3d;\n    DomUtil.addClass(container, 'leaflet-container' + (Browser.touch ? ' leaflet-touch' : '') + (Browser.retina ? ' leaflet-retina' : '') + (Browser.ielt9 ? ' leaflet-oldie' : '') + (Browser.safari ? ' leaflet-safari' : '') + (this._fadeAnimated ? ' leaflet-fade-anim' : ''));\n    var position = DomUtil.getStyle(container, 'position');\n    if (position !== 'absolute' && position !== 'relative' && position !== 'fixed' && position !== 'sticky') {\n      container.style.position = 'relative';\n    }\n    this._initPanes();\n    if (this._initControlPos) {\n      this._initControlPos();\n    }\n  },\n  _initPanes: function () {\n    var panes = this._panes = {};\n    this._paneRenderers = {};\n\n    // @section\n    //\n    // Panes are DOM elements used to control the ordering of layers on the map. You\n    // can access panes with [`map.getPane`](#map-getpane) or\n    // [`map.getPanes`](#map-getpanes) methods. New panes can be created with the\n    // [`map.createPane`](#map-createpane) method.\n    //\n    // Every map has the following default panes that differ only in zIndex.\n    //\n    // @pane mapPane: HTMLElement = 'auto'\n    // Pane that contains all other map panes\n\n    this._mapPane = this.createPane('mapPane', this._container);\n    DomUtil.setPosition(this._mapPane, new Point(0, 0));\n\n    // @pane tilePane: HTMLElement = 200\n    // Pane for `GridLayer`s and `TileLayer`s\n    this.createPane('tilePane');\n    // @pane overlayPane: HTMLElement = 400\n    // Pane for vectors (`Path`s, like `Polyline`s and `Polygon`s), `ImageOverlay`s and `VideoOverlay`s\n    this.createPane('overlayPane');\n    // @pane shadowPane: HTMLElement = 500\n    // Pane for overlay shadows (e.g. `Marker` shadows)\n    this.createPane('shadowPane');\n    // @pane markerPane: HTMLElement = 600\n    // Pane for `Icon`s of `Marker`s\n    this.createPane('markerPane');\n    // @pane tooltipPane: HTMLElement = 650\n    // Pane for `Tooltip`s.\n    this.createPane('tooltipPane');\n    // @pane popupPane: HTMLElement = 700\n    // Pane for `Popup`s.\n    this.createPane('popupPane');\n    if (!this.options.markerZoomAnimation) {\n      DomUtil.addClass(panes.markerPane, 'leaflet-zoom-hide');\n      DomUtil.addClass(panes.shadowPane, 'leaflet-zoom-hide');\n    }\n  },\n  // private methods that modify map state\n\n  // @section Map state change events\n  _resetView: function (center, zoom, noMoveStart) {\n    DomUtil.setPosition(this._mapPane, new Point(0, 0));\n    var loading = !this._loaded;\n    this._loaded = true;\n    zoom = this._limitZoom(zoom);\n    this.fire('viewprereset');\n    var zoomChanged = this._zoom !== zoom;\n    this._moveStart(zoomChanged, noMoveStart)._move(center, zoom)._moveEnd(zoomChanged);\n\n    // @event viewreset: Event\n    // Fired when the map needs to redraw its content (this usually happens\n    // on map zoom or load). Very useful for creating custom overlays.\n    this.fire('viewreset');\n\n    // @event load: Event\n    // Fired when the map is initialized (when its center and zoom are set\n    // for the first time).\n    if (loading) {\n      this.fire('load');\n    }\n  },\n  _moveStart: function (zoomChanged, noMoveStart) {\n    // @event zoomstart: Event\n    // Fired when the map zoom is about to change (e.g. before zoom animation).\n    // @event movestart: Event\n    // Fired when the view of the map starts changing (e.g. user starts dragging the map).\n    if (zoomChanged) {\n      this.fire('zoomstart');\n    }\n    if (!noMoveStart) {\n      this.fire('movestart');\n    }\n    return this;\n  },\n  _move: function (center, zoom, data, supressEvent) {\n    if (zoom === undefined) {\n      zoom = this._zoom;\n    }\n    var zoomChanged = this._zoom !== zoom;\n    this._zoom = zoom;\n    this._lastCenter = center;\n    this._pixelOrigin = this._getNewPixelOrigin(center);\n    if (!supressEvent) {\n      // @event zoom: Event\n      // Fired repeatedly during any change in zoom level,\n      // including zoom and fly animations.\n      if (zoomChanged || data && data.pinch) {\n        // Always fire 'zoom' if pinching because #3530\n        this.fire('zoom', data);\n      }\n\n      // @event move: Event\n      // Fired repeatedly during any movement of the map,\n      // including pan and fly animations.\n      this.fire('move', data);\n    } else if (data && data.pinch) {\n      // Always fire 'zoom' if pinching because #3530\n      this.fire('zoom', data);\n    }\n    return this;\n  },\n  _moveEnd: function (zoomChanged) {\n    // @event zoomend: Event\n    // Fired when the map zoom changed, after any animations.\n    if (zoomChanged) {\n      this.fire('zoomend');\n    }\n\n    // @event moveend: Event\n    // Fired when the center of the map stops changing\n    // (e.g. user stopped dragging the map or after non-centered zoom).\n    return this.fire('moveend');\n  },\n  _stop: function () {\n    Util.cancelAnimFrame(this._flyToFrame);\n    if (this._panAnim) {\n      this._panAnim.stop();\n    }\n    return this;\n  },\n  _rawPanBy: function (offset) {\n    DomUtil.setPosition(this._mapPane, this._getMapPanePos().subtract(offset));\n  },\n  _getZoomSpan: function () {\n    return this.getMaxZoom() - this.getMinZoom();\n  },\n  _panInsideMaxBounds: function () {\n    if (!this._enforcingBounds) {\n      this.panInsideBounds(this.options.maxBounds);\n    }\n  },\n  _checkIfLoaded: function () {\n    if (!this._loaded) {\n      throw new Error('Set map center and zoom first.');\n    }\n  },\n  // DOM event handling\n\n  // @section Interaction events\n  _initEvents: function (remove) {\n    this._targets = {};\n    this._targets[Util.stamp(this._container)] = this;\n    var onOff = remove ? DomEvent.off : DomEvent.on;\n\n    // @event click: MouseEvent\n    // Fired when the user clicks (or taps) the map.\n    // @event dblclick: MouseEvent\n    // Fired when the user double-clicks (or double-taps) the map.\n    // @event mousedown: MouseEvent\n    // Fired when the user pushes the mouse button on the map.\n    // @event mouseup: MouseEvent\n    // Fired when the user releases the mouse button on the map.\n    // @event mouseover: MouseEvent\n    // Fired when the mouse enters the map.\n    // @event mouseout: MouseEvent\n    // Fired when the mouse leaves the map.\n    // @event mousemove: MouseEvent\n    // Fired while the mouse moves over the map.\n    // @event contextmenu: MouseEvent\n    // Fired when the user pushes the right mouse button on the map, prevents\n    // default browser context menu from showing if there are listeners on\n    // this event. Also fired on mobile when the user holds a single touch\n    // for a second (also called long press).\n    // @event keypress: KeyboardEvent\n    // Fired when the user presses a key from the keyboard that produces a character value while the map is focused.\n    // @event keydown: KeyboardEvent\n    // Fired when the user presses a key from the keyboard while the map is focused. Unlike the `keypress` event,\n    // the `keydown` event is fired for keys that produce a character value and for keys\n    // that do not produce a character value.\n    // @event keyup: KeyboardEvent\n    // Fired when the user releases a key from the keyboard while the map is focused.\n    onOff(this._container, 'click dblclick mousedown mouseup ' + 'mouseover mouseout mousemove contextmenu keypress keydown keyup', this._handleDOMEvent, this);\n    if (this.options.trackResize) {\n      onOff(window, 'resize', this._onResize, this);\n    }\n    if (Browser.any3d && this.options.transform3DLimit) {\n      (remove ? this.off : this.on).call(this, 'moveend', this._onMoveEnd);\n    }\n  },\n  _onResize: function () {\n    Util.cancelAnimFrame(this._resizeRequest);\n    this._resizeRequest = Util.requestAnimFrame(function () {\n      this.invalidateSize({\n        debounceMoveend: true\n      });\n    }, this);\n  },\n  _onScroll: function () {\n    this._container.scrollTop = 0;\n    this._container.scrollLeft = 0;\n  },\n  _onMoveEnd: function () {\n    var pos = this._getMapPanePos();\n    if (Math.max(Math.abs(pos.x), Math.abs(pos.y)) >= this.options.transform3DLimit) {\n      // https://bugzilla.mozilla.org/show_bug.cgi?id=1203873 but Webkit also have\n      // a pixel offset on very high values, see: https://jsfiddle.net/dg6r5hhb/\n      this._resetView(this.getCenter(), this.getZoom());\n    }\n  },\n  _findEventTargets: function (e, type) {\n    var targets = [],\n      target,\n      isHover = type === 'mouseout' || type === 'mouseover',\n      src = e.target || e.srcElement,\n      dragging = false;\n    while (src) {\n      target = this._targets[Util.stamp(src)];\n      if (target && (type === 'click' || type === 'preclick') && this._draggableMoved(target)) {\n        // Prevent firing click after you just dragged an object.\n        dragging = true;\n        break;\n      }\n      if (target && target.listens(type, true)) {\n        if (isHover && !DomEvent.isExternalTarget(src, e)) {\n          break;\n        }\n        targets.push(target);\n        if (isHover) {\n          break;\n        }\n      }\n      if (src === this._container) {\n        break;\n      }\n      src = src.parentNode;\n    }\n    if (!targets.length && !dragging && !isHover && this.listens(type, true)) {\n      targets = [this];\n    }\n    return targets;\n  },\n  _isClickDisabled: function (el) {\n    while (el && el !== this._container) {\n      if (el['_leaflet_disable_click']) {\n        return true;\n      }\n      el = el.parentNode;\n    }\n  },\n  _handleDOMEvent: function (e) {\n    var el = e.target || e.srcElement;\n    if (!this._loaded || el['_leaflet_disable_events'] || e.type === 'click' && this._isClickDisabled(el)) {\n      return;\n    }\n    var type = e.type;\n    if (type === 'mousedown') {\n      // prevents outline when clicking on keyboard-focusable element\n      DomUtil.preventOutline(el);\n    }\n    this._fireDOMEvent(e, type);\n  },\n  _mouseEvents: ['click', 'dblclick', 'mouseover', 'mouseout', 'contextmenu'],\n  _fireDOMEvent: function (e, type, canvasTargets) {\n    if (e.type === 'click') {\n      // Fire a synthetic 'preclick' event which propagates up (mainly for closing popups).\n      // @event preclick: MouseEvent\n      // Fired before mouse click on the map (sometimes useful when you\n      // want something to happen on click before any existing click\n      // handlers start running).\n      var synth = Util.extend({}, e);\n      synth.type = 'preclick';\n      this._fireDOMEvent(synth, synth.type, canvasTargets);\n    }\n\n    // Find the layer the event is propagating from and its parents.\n    var targets = this._findEventTargets(e, type);\n    if (canvasTargets) {\n      var filtered = []; // pick only targets with listeners\n      for (var i = 0; i < canvasTargets.length; i++) {\n        if (canvasTargets[i].listens(type, true)) {\n          filtered.push(canvasTargets[i]);\n        }\n      }\n      targets = filtered.concat(targets);\n    }\n    if (!targets.length) {\n      return;\n    }\n    if (type === 'contextmenu') {\n      DomEvent.preventDefault(e);\n    }\n    var target = targets[0];\n    var data = {\n      originalEvent: e\n    };\n    if (e.type !== 'keypress' && e.type !== 'keydown' && e.type !== 'keyup') {\n      var isMarker = target.getLatLng && (!target._radius || target._radius <= 10);\n      data.containerPoint = isMarker ? this.latLngToContainerPoint(target.getLatLng()) : this.mouseEventToContainerPoint(e);\n      data.layerPoint = this.containerPointToLayerPoint(data.containerPoint);\n      data.latlng = isMarker ? target.getLatLng() : this.layerPointToLatLng(data.layerPoint);\n    }\n    for (i = 0; i < targets.length; i++) {\n      targets[i].fire(type, data, true);\n      if (data.originalEvent._stopped || targets[i].options.bubblingMouseEvents === false && Util.indexOf(this._mouseEvents, type) !== -1) {\n        return;\n      }\n    }\n  },\n  _draggableMoved: function (obj) {\n    obj = obj.dragging && obj.dragging.enabled() ? obj : this;\n    return obj.dragging && obj.dragging.moved() || this.boxZoom && this.boxZoom.moved();\n  },\n  _clearHandlers: function () {\n    for (var i = 0, len = this._handlers.length; i < len; i++) {\n      this._handlers[i].disable();\n    }\n  },\n  // @section Other Methods\n\n  // @method whenReady(fn: Function, context?: Object): this\n  // Runs the given function `fn` when the map gets initialized with\n  // a view (center and zoom) and at least one layer, or immediately\n  // if it's already initialized, optionally passing a function context.\n  whenReady: function (callback, context) {\n    if (this._loaded) {\n      callback.call(context || this, {\n        target: this\n      });\n    } else {\n      this.on('load', callback, context);\n    }\n    return this;\n  },\n  // private methods for getting map state\n\n  _getMapPanePos: function () {\n    return DomUtil.getPosition(this._mapPane) || new Point(0, 0);\n  },\n  _moved: function () {\n    var pos = this._getMapPanePos();\n    return pos && !pos.equals([0, 0]);\n  },\n  _getTopLeftPoint: function (center, zoom) {\n    var pixelOrigin = center && zoom !== undefined ? this._getNewPixelOrigin(center, zoom) : this.getPixelOrigin();\n    return pixelOrigin.subtract(this._getMapPanePos());\n  },\n  _getNewPixelOrigin: function (center, zoom) {\n    var viewHalf = this.getSize()._divideBy(2);\n    return this.project(center, zoom)._subtract(viewHalf)._add(this._getMapPanePos())._round();\n  },\n  _latLngToNewLayerPoint: function (latlng, zoom, center) {\n    var topLeft = this._getNewPixelOrigin(center, zoom);\n    return this.project(latlng, zoom)._subtract(topLeft);\n  },\n  _latLngBoundsToNewLayerBounds: function (latLngBounds, zoom, center) {\n    var topLeft = this._getNewPixelOrigin(center, zoom);\n    return toBounds([this.project(latLngBounds.getSouthWest(), zoom)._subtract(topLeft), this.project(latLngBounds.getNorthWest(), zoom)._subtract(topLeft), this.project(latLngBounds.getSouthEast(), zoom)._subtract(topLeft), this.project(latLngBounds.getNorthEast(), zoom)._subtract(topLeft)]);\n  },\n  // layer point of the current center\n  _getCenterLayerPoint: function () {\n    return this.containerPointToLayerPoint(this.getSize()._divideBy(2));\n  },\n  // offset of the specified place to the current center in pixels\n  _getCenterOffset: function (latlng) {\n    return this.latLngToLayerPoint(latlng).subtract(this._getCenterLayerPoint());\n  },\n  // adjust center for view to get inside bounds\n  _limitCenter: function (center, zoom, bounds) {\n    if (!bounds) {\n      return center;\n    }\n    var centerPoint = this.project(center, zoom),\n      viewHalf = this.getSize().divideBy(2),\n      viewBounds = new Bounds(centerPoint.subtract(viewHalf), centerPoint.add(viewHalf)),\n      offset = this._getBoundsOffset(viewBounds, bounds, zoom);\n\n    // If offset is less than a pixel, ignore.\n    // This prevents unstable projections from getting into\n    // an infinite loop of tiny offsets.\n    if (Math.abs(offset.x) <= 1 && Math.abs(offset.y) <= 1) {\n      return center;\n    }\n    return this.unproject(centerPoint.add(offset), zoom);\n  },\n  // adjust offset for view to get inside bounds\n  _limitOffset: function (offset, bounds) {\n    if (!bounds) {\n      return offset;\n    }\n    var viewBounds = this.getPixelBounds(),\n      newBounds = new Bounds(viewBounds.min.add(offset), viewBounds.max.add(offset));\n    return offset.add(this._getBoundsOffset(newBounds, bounds));\n  },\n  // returns offset needed for pxBounds to get inside maxBounds at a specified zoom\n  _getBoundsOffset: function (pxBounds, maxBounds, zoom) {\n    var projectedMaxBounds = toBounds(this.project(maxBounds.getNorthEast(), zoom), this.project(maxBounds.getSouthWest(), zoom)),\n      minOffset = projectedMaxBounds.min.subtract(pxBounds.min),\n      maxOffset = projectedMaxBounds.max.subtract(pxBounds.max),\n      dx = this._rebound(minOffset.x, -maxOffset.x),\n      dy = this._rebound(minOffset.y, -maxOffset.y);\n    return new Point(dx, dy);\n  },\n  _rebound: function (left, right) {\n    return left + right > 0 ? Math.round(left - right) / 2 : Math.max(0, Math.ceil(left)) - Math.max(0, Math.floor(right));\n  },\n  _limitZoom: function (zoom) {\n    var min = this.getMinZoom(),\n      max = this.getMaxZoom(),\n      snap = Browser.any3d ? this.options.zoomSnap : 1;\n    if (snap) {\n      zoom = Math.round(zoom / snap) * snap;\n    }\n    return Math.max(min, Math.min(max, zoom));\n  },\n  _onPanTransitionStep: function () {\n    this.fire('move');\n  },\n  _onPanTransitionEnd: function () {\n    DomUtil.removeClass(this._mapPane, 'leaflet-pan-anim');\n    this.fire('moveend');\n  },\n  _tryAnimatedPan: function (center, options) {\n    // difference between the new and current centers in pixels\n    var offset = this._getCenterOffset(center)._trunc();\n\n    // don't animate too far unless animate: true specified in options\n    if ((options && options.animate) !== true && !this.getSize().contains(offset)) {\n      return false;\n    }\n    this.panBy(offset, options);\n    return true;\n  },\n  _createAnimProxy: function () {\n    var proxy = this._proxy = DomUtil.create('div', 'leaflet-proxy leaflet-zoom-animated');\n    this._panes.mapPane.appendChild(proxy);\n    this.on('zoomanim', function (e) {\n      var prop = DomUtil.TRANSFORM,\n        transform = this._proxy.style[prop];\n      DomUtil.setTransform(this._proxy, this.project(e.center, e.zoom), this.getZoomScale(e.zoom, 1));\n\n      // workaround for case when transform is the same and so transitionend event is not fired\n      if (transform === this._proxy.style[prop] && this._animatingZoom) {\n        this._onZoomTransitionEnd();\n      }\n    }, this);\n    this.on('load moveend', this._animMoveEnd, this);\n    this._on('unload', this._destroyAnimProxy, this);\n  },\n  _destroyAnimProxy: function () {\n    DomUtil.remove(this._proxy);\n    this.off('load moveend', this._animMoveEnd, this);\n    delete this._proxy;\n  },\n  _animMoveEnd: function () {\n    var c = this.getCenter(),\n      z = this.getZoom();\n    DomUtil.setTransform(this._proxy, this.project(c, z), this.getZoomScale(z, 1));\n  },\n  _catchTransitionEnd: function (e) {\n    if (this._animatingZoom && e.propertyName.indexOf('transform') >= 0) {\n      this._onZoomTransitionEnd();\n    }\n  },\n  _nothingToAnimate: function () {\n    return !this._container.getElementsByClassName('leaflet-zoom-animated').length;\n  },\n  _tryAnimatedZoom: function (center, zoom, options) {\n    if (this._animatingZoom) {\n      return true;\n    }\n    options = options || {};\n\n    // don't animate if disabled, not supported or zoom difference is too large\n    if (!this._zoomAnimated || options.animate === false || this._nothingToAnimate() || Math.abs(zoom - this._zoom) > this.options.zoomAnimationThreshold) {\n      return false;\n    }\n\n    // offset is the pixel coords of the zoom origin relative to the current center\n    var scale = this.getZoomScale(zoom),\n      offset = this._getCenterOffset(center)._divideBy(1 - 1 / scale);\n\n    // don't animate if the zoom origin isn't within one screen from the current center, unless forced\n    if (options.animate !== true && !this.getSize().contains(offset)) {\n      return false;\n    }\n    Util.requestAnimFrame(function () {\n      this._moveStart(true, false)._animateZoom(center, zoom, true);\n    }, this);\n    return true;\n  },\n  _animateZoom: function (center, zoom, startAnim, noUpdate) {\n    if (!this._mapPane) {\n      return;\n    }\n    if (startAnim) {\n      this._animatingZoom = true;\n\n      // remember what center/zoom to set after animation\n      this._animateToCenter = center;\n      this._animateToZoom = zoom;\n      DomUtil.addClass(this._mapPane, 'leaflet-zoom-anim');\n    }\n\n    // @section Other Events\n    // @event zoomanim: ZoomAnimEvent\n    // Fired at least once per zoom animation. For continuous zoom, like pinch zooming, fired once per frame during zoom.\n    this.fire('zoomanim', {\n      center: center,\n      zoom: zoom,\n      noUpdate: noUpdate\n    });\n    if (!this._tempFireZoomEvent) {\n      this._tempFireZoomEvent = this._zoom !== this._animateToZoom;\n    }\n    this._move(this._animateToCenter, this._animateToZoom, undefined, true);\n\n    // Work around webkit not firing 'transitionend', see https://github.com/Leaflet/Leaflet/issues/3689, 2693\n    setTimeout(Util.bind(this._onZoomTransitionEnd, this), 250);\n  },\n  _onZoomTransitionEnd: function () {\n    if (!this._animatingZoom) {\n      return;\n    }\n    if (this._mapPane) {\n      DomUtil.removeClass(this._mapPane, 'leaflet-zoom-anim');\n    }\n    this._animatingZoom = false;\n    this._move(this._animateToCenter, this._animateToZoom, undefined, true);\n    if (this._tempFireZoomEvent) {\n      this.fire('zoom');\n    }\n    delete this._tempFireZoomEvent;\n    this.fire('move');\n    this._moveEnd(true);\n  }\n});\n\n// @section\n\n// @factory L.map(id: String, options?: Map options)\n// Instantiates a map object given the DOM ID of a `<div>` element\n// and optionally an object literal with `Map options`.\n//\n// @alternative\n// @factory L.map(el: HTMLElement, options?: Map options)\n// Instantiates a map object given an instance of a `<div>` HTML element\n// and optionally an object literal with `Map options`.\nexport function createMap(id, options) {\n  return new Map(id, options);\n}","map":{"version":3,"names":["Util","Evented","EPSG3857","Point","toPoint","Bounds","toBounds","LatLng","toLatLng","LatLngBounds","toLatLngBounds","Browser","DomEvent","DomUtil","PosAnimation","Map","extend","options","crs","center","undefined","zoom","minZoom","maxZoom","layers","maxBounds","renderer","zoomAnimation","zoomAnimationThreshold","fadeAnimation","markerZoomAnimation","transform3DLimit","zoomSnap","zoomDelta","trackResize","initialize","id","setOptions","_handlers","_layers","_zoomBoundLayers","_sizeChanged","_initContainer","_initLayout","_onResize","bind","_initEvents","setMaxBounds","_zoom","_limitZoom","setView","reset","callInitHooks","_zoomAnimated","TRANSITION","any3d","mobileOpera","_createAnimProxy","on","_proxy","TRANSITION_END","_catchTransitionEnd","_addLayers","_limitCenter","_stop","_loaded","animate","pan","duration","moved","_tryAnimatedZoom","_tryAnimatedPan","clearTimeout","_sizeTimer","_resetView","noMoveStart","setZoom","getCenter","zoomIn","delta","zoomOut","setZoomAround","latlng","scale","getZoomScale","viewHalf","getSize","divideBy","containerPoint","latLngToContainerPoint","centerOffset","subtract","multiplyBy","newCenter","containerPointToLatLng","add","_getBoundsCenterZoom","bounds","getBounds","paddingTL","paddingTopLeft","padding","paddingBR","paddingBottomRight","getBoundsZoom","Math","min","Infinity","paddingOffset","swPoint","project","getSouthWest","nePoint","getNorthEast","unproject","fitBounds","isValid","Error","target","fitWorld","panTo","panBy","offset","round","x","y","fire","contains","getZoom","_panAnim","_onPanTransitionStep","_onPanTransitionEnd","addClass","_mapPane","newPos","_getMapPanePos","run","easeLinearity","_rawPanBy","flyTo","targetCenter","targetZoom","from","to","size","startZoom","w0","max","w1","u1","distanceTo","rho","rho2","r","i","s1","s2","t1","b1","b","sq","sqrt","log","sinh","n","exp","cosh","tanh","r0","w","s","u","easeOut","t","pow","start","Date","now","S","frame","_flyToFrame","requestAnimFrame","_move","getScaleZoom","_moveEnd","_moveStart","call","flyToBounds","listens","_panInsideMaxBounds","off","setMinZoom","oldZoom","setMaxZoom","panInsideBounds","_enforcingBounds","equals","panInside","pixelCenter","pixelPoint","pixelBounds","getPixelBounds","paddedBounds","paddedSize","invalidateSize","oldSize","_lastCenter","newSize","oldCenter","debounceMoveend","setTimeout","stop","locate","_locateOptions","timeout","watch","navigator","_handleGeolocationError","code","message","onResponse","_handleGeolocationResponse","onError","_locationWatchId","geolocation","watchPosition","getCurrentPosition","stopLocate","clearWatch","error","_container","_leaflet_id","c","pos","lat","coords","latitude","lng","longitude","accuracy","data","timestamp","addHandler","name","HandlerClass","handler","push","enable","remove","_containerId","e","_clearControlPos","_resizeRequest","cancelAnimFrame","_clearHandlers","_panes","_renderer","createPane","container","className","replace","pane","create","_checkIfLoaded","_moved","clone","layerPointToLatLng","_getCenterLayerPoint","sw","getBottomLeft","ne","getTopRight","getMinZoom","_layersMinZoom","getMaxZoom","_layersMaxZoom","inside","nw","getNorthWest","se","getSouthEast","boundsSize","snap","scalex","scaley","ceil","floor","_size","clientWidth","clientHeight","topLeftPoint","_getTopLeftPoint","getPixelOrigin","_pixelOrigin","getPixelWorldBounds","getProjectedBounds","getPane","getPanes","getContainer","toZoom","fromZoom","isNaN","latLngToPoint","point","pointToLatLng","projectedPoint","latLngToLayerPoint","_round","_subtract","wrapLatLng","wrapLatLngBounds","distance","latlng1","latlng2","containerPointToLayerPoint","layerPointToContainerPoint","layerPoint","mouseEventToContainerPoint","getMousePosition","mouseEventToLayerPoint","mouseEventToLatLng","get","_onScroll","stamp","_fadeAnimated","touch","retina","ielt9","safari","position","getStyle","style","_initPanes","_initControlPos","panes","_paneRenderers","setPosition","markerPane","shadowPane","loading","zoomChanged","supressEvent","_getNewPixelOrigin","pinch","_getZoomSpan","_targets","onOff","_handleDOMEvent","window","_onMoveEnd","scrollTop","scrollLeft","abs","_findEventTargets","type","targets","isHover","src","srcElement","dragging","_draggableMoved","isExternalTarget","parentNode","length","_isClickDisabled","el","preventOutline","_fireDOMEvent","_mouseEvents","canvasTargets","synth","filtered","concat","preventDefault","originalEvent","isMarker","getLatLng","_radius","_stopped","bubblingMouseEvents","indexOf","obj","enabled","boxZoom","len","disable","whenReady","callback","context","getPosition","pixelOrigin","_divideBy","_add","_latLngToNewLayerPoint","topLeft","_latLngBoundsToNewLayerBounds","latLngBounds","_getCenterOffset","centerPoint","viewBounds","_getBoundsOffset","_limitOffset","newBounds","pxBounds","projectedMaxBounds","minOffset","maxOffset","dx","_rebound","dy","left","right","removeClass","_trunc","proxy","mapPane","appendChild","prop","TRANSFORM","transform","setTransform","_animatingZoom","_onZoomTransitionEnd","_animMoveEnd","_on","_destroyAnimProxy","z","propertyName","_nothingToAnimate","getElementsByClassName","_animateZoom","startAnim","noUpdate","_animateToCenter","_animateToZoom","_tempFireZoomEvent","createMap"],"sources":["C:/Users/aless/OneDrive/Área de Trabalho/Registro Ponto front-end GitHub/ReactProjects/my-app/node_modules/leaflet/src/map/Map.js"],"sourcesContent":["import * as Util from '../core/Util';\r\nimport {Evented} from '../core/Events';\r\nimport {EPSG3857} from '../geo/crs/CRS.EPSG3857';\r\nimport {Point, toPoint} from '../geometry/Point';\r\nimport {Bounds, toBounds} from '../geometry/Bounds';\r\nimport {LatLng, toLatLng} from '../geo/LatLng';\r\nimport {LatLngBounds, toLatLngBounds} from '../geo/LatLngBounds';\r\nimport Browser from '../core/Browser';\r\nimport * as DomEvent from '../dom/DomEvent';\r\nimport * as DomUtil from '../dom/DomUtil';\r\nimport {PosAnimation} from '../dom/PosAnimation';\r\n\r\n/*\r\n * @class Map\r\n * @aka L.Map\r\n * @inherits Evented\r\n *\r\n * The central class of the API — it is used to create a map on a page and manipulate it.\r\n *\r\n * @example\r\n *\r\n * ```js\r\n * // initialize the map on the \"map\" div with a given center and zoom\r\n * var map = L.map('map', {\r\n * \tcenter: [51.505, -0.09],\r\n * \tzoom: 13\r\n * });\r\n * ```\r\n *\r\n */\r\n\r\nexport var Map = Evented.extend({\r\n\r\n\toptions: {\r\n\t\t// @section Map State Options\r\n\t\t// @option crs: CRS = L.CRS.EPSG3857\r\n\t\t// The [Coordinate Reference System](#crs) to use. Don't change this if you're not\r\n\t\t// sure what it means.\r\n\t\tcrs: EPSG3857,\r\n\r\n\t\t// @option center: LatLng = undefined\r\n\t\t// Initial geographic center of the map\r\n\t\tcenter: undefined,\r\n\r\n\t\t// @option zoom: Number = undefined\r\n\t\t// Initial map zoom level\r\n\t\tzoom: undefined,\r\n\r\n\t\t// @option minZoom: Number = *\r\n\t\t// Minimum zoom level of the map.\r\n\t\t// If not specified and at least one `GridLayer` or `TileLayer` is in the map,\r\n\t\t// the lowest of their `minZoom` options will be used instead.\r\n\t\tminZoom: undefined,\r\n\r\n\t\t// @option maxZoom: Number = *\r\n\t\t// Maximum zoom level of the map.\r\n\t\t// If not specified and at least one `GridLayer` or `TileLayer` is in the map,\r\n\t\t// the highest of their `maxZoom` options will be used instead.\r\n\t\tmaxZoom: undefined,\r\n\r\n\t\t// @option layers: Layer[] = []\r\n\t\t// Array of layers that will be added to the map initially\r\n\t\tlayers: [],\r\n\r\n\t\t// @option maxBounds: LatLngBounds = null\r\n\t\t// When this option is set, the map restricts the view to the given\r\n\t\t// geographical bounds, bouncing the user back if the user tries to pan\r\n\t\t// outside the view. To set the restriction dynamically, use\r\n\t\t// [`setMaxBounds`](#map-setmaxbounds) method.\r\n\t\tmaxBounds: undefined,\r\n\r\n\t\t// @option renderer: Renderer = *\r\n\t\t// The default method for drawing vector layers on the map. `L.SVG`\r\n\t\t// or `L.Canvas` by default depending on browser support.\r\n\t\trenderer: undefined,\r\n\r\n\r\n\t\t// @section Animation Options\r\n\t\t// @option zoomAnimation: Boolean = true\r\n\t\t// Whether the map zoom animation is enabled. By default it's enabled\r\n\t\t// in all browsers that support CSS3 Transitions except Android.\r\n\t\tzoomAnimation: true,\r\n\r\n\t\t// @option zoomAnimationThreshold: Number = 4\r\n\t\t// Won't animate zoom if the zoom difference exceeds this value.\r\n\t\tzoomAnimationThreshold: 4,\r\n\r\n\t\t// @option fadeAnimation: Boolean = true\r\n\t\t// Whether the tile fade animation is enabled. By default it's enabled\r\n\t\t// in all browsers that support CSS3 Transitions except Android.\r\n\t\tfadeAnimation: true,\r\n\r\n\t\t// @option markerZoomAnimation: Boolean = true\r\n\t\t// Whether markers animate their zoom with the zoom animation, if disabled\r\n\t\t// they will disappear for the length of the animation. By default it's\r\n\t\t// enabled in all browsers that support CSS3 Transitions except Android.\r\n\t\tmarkerZoomAnimation: true,\r\n\r\n\t\t// @option transform3DLimit: Number = 2^23\r\n\t\t// Defines the maximum size of a CSS translation transform. The default\r\n\t\t// value should not be changed unless a web browser positions layers in\r\n\t\t// the wrong place after doing a large `panBy`.\r\n\t\ttransform3DLimit: 8388608, // Precision limit of a 32-bit float\r\n\r\n\t\t// @section Interaction Options\r\n\t\t// @option zoomSnap: Number = 1\r\n\t\t// Forces the map's zoom level to always be a multiple of this, particularly\r\n\t\t// right after a [`fitBounds()`](#map-fitbounds) or a pinch-zoom.\r\n\t\t// By default, the zoom level snaps to the nearest integer; lower values\r\n\t\t// (e.g. `0.5` or `0.1`) allow for greater granularity. A value of `0`\r\n\t\t// means the zoom level will not be snapped after `fitBounds` or a pinch-zoom.\r\n\t\tzoomSnap: 1,\r\n\r\n\t\t// @option zoomDelta: Number = 1\r\n\t\t// Controls how much the map's zoom level will change after a\r\n\t\t// [`zoomIn()`](#map-zoomin), [`zoomOut()`](#map-zoomout), pressing `+`\r\n\t\t// or `-` on the keyboard, or using the [zoom controls](#control-zoom).\r\n\t\t// Values smaller than `1` (e.g. `0.5`) allow for greater granularity.\r\n\t\tzoomDelta: 1,\r\n\r\n\t\t// @option trackResize: Boolean = true\r\n\t\t// Whether the map automatically handles browser window resize to update itself.\r\n\t\ttrackResize: true\r\n\t},\r\n\r\n\tinitialize: function (id, options) { // (HTMLElement or String, Object)\r\n\t\toptions = Util.setOptions(this, options);\r\n\r\n\t\t// Make sure to assign internal flags at the beginning,\r\n\t\t// to avoid inconsistent state in some edge cases.\r\n\t\tthis._handlers = [];\r\n\t\tthis._layers = {};\r\n\t\tthis._zoomBoundLayers = {};\r\n\t\tthis._sizeChanged = true;\r\n\r\n\t\tthis._initContainer(id);\r\n\t\tthis._initLayout();\r\n\r\n\t\t// hack for https://github.com/Leaflet/Leaflet/issues/1980\r\n\t\tthis._onResize = Util.bind(this._onResize, this);\r\n\r\n\t\tthis._initEvents();\r\n\r\n\t\tif (options.maxBounds) {\r\n\t\t\tthis.setMaxBounds(options.maxBounds);\r\n\t\t}\r\n\r\n\t\tif (options.zoom !== undefined) {\r\n\t\t\tthis._zoom = this._limitZoom(options.zoom);\r\n\t\t}\r\n\r\n\t\tif (options.center && options.zoom !== undefined) {\r\n\t\t\tthis.setView(toLatLng(options.center), options.zoom, {reset: true});\r\n\t\t}\r\n\r\n\t\tthis.callInitHooks();\r\n\r\n\t\t// don't animate on browsers without hardware-accelerated transitions or old Android/Opera\r\n\t\tthis._zoomAnimated = DomUtil.TRANSITION && Browser.any3d && !Browser.mobileOpera &&\r\n\t\t\t\tthis.options.zoomAnimation;\r\n\r\n\t\t// zoom transitions run with the same duration for all layers, so if one of transitionend events\r\n\t\t// happens after starting zoom animation (propagating to the map pane), we know that it ended globally\r\n\t\tif (this._zoomAnimated) {\r\n\t\t\tthis._createAnimProxy();\r\n\t\t\tDomEvent.on(this._proxy, DomUtil.TRANSITION_END, this._catchTransitionEnd, this);\r\n\t\t}\r\n\r\n\t\tthis._addLayers(this.options.layers);\r\n\t},\r\n\r\n\r\n\t// @section Methods for modifying map state\r\n\r\n\t// @method setView(center: LatLng, zoom: Number, options?: Zoom/pan options): this\r\n\t// Sets the view of the map (geographical center and zoom) with the given\r\n\t// animation options.\r\n\tsetView: function (center, zoom, options) {\r\n\r\n\t\tzoom = zoom === undefined ? this._zoom : this._limitZoom(zoom);\r\n\t\tcenter = this._limitCenter(toLatLng(center), zoom, this.options.maxBounds);\r\n\t\toptions = options || {};\r\n\r\n\t\tthis._stop();\r\n\r\n\t\tif (this._loaded && !options.reset && options !== true) {\r\n\r\n\t\t\tif (options.animate !== undefined) {\r\n\t\t\t\toptions.zoom = Util.extend({animate: options.animate}, options.zoom);\r\n\t\t\t\toptions.pan = Util.extend({animate: options.animate, duration: options.duration}, options.pan);\r\n\t\t\t}\r\n\r\n\t\t\t// try animating pan or zoom\r\n\t\t\tvar moved = (this._zoom !== zoom) ?\r\n\t\t\t\tthis._tryAnimatedZoom && this._tryAnimatedZoom(center, zoom, options.zoom) :\r\n\t\t\t\tthis._tryAnimatedPan(center, options.pan);\r\n\r\n\t\t\tif (moved) {\r\n\t\t\t\t// prevent resize handler call, the view will refresh after animation anyway\r\n\t\t\t\tclearTimeout(this._sizeTimer);\r\n\t\t\t\treturn this;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// animation didn't start, just reset the map view\r\n\t\tthis._resetView(center, zoom, options.pan && options.pan.noMoveStart);\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\t// @method setZoom(zoom: Number, options?: Zoom/pan options): this\r\n\t// Sets the zoom of the map.\r\n\tsetZoom: function (zoom, options) {\r\n\t\tif (!this._loaded) {\r\n\t\t\tthis._zoom = zoom;\r\n\t\t\treturn this;\r\n\t\t}\r\n\t\treturn this.setView(this.getCenter(), zoom, {zoom: options});\r\n\t},\r\n\r\n\t// @method zoomIn(delta?: Number, options?: Zoom options): this\r\n\t// Increases the zoom of the map by `delta` ([`zoomDelta`](#map-zoomdelta) by default).\r\n\tzoomIn: function (delta, options) {\r\n\t\tdelta = delta || (Browser.any3d ? this.options.zoomDelta : 1);\r\n\t\treturn this.setZoom(this._zoom + delta, options);\r\n\t},\r\n\r\n\t// @method zoomOut(delta?: Number, options?: Zoom options): this\r\n\t// Decreases the zoom of the map by `delta` ([`zoomDelta`](#map-zoomdelta) by default).\r\n\tzoomOut: function (delta, options) {\r\n\t\tdelta = delta || (Browser.any3d ? this.options.zoomDelta : 1);\r\n\t\treturn this.setZoom(this._zoom - delta, options);\r\n\t},\r\n\r\n\t// @method setZoomAround(latlng: LatLng, zoom: Number, options: Zoom options): this\r\n\t// Zooms the map while keeping a specified geographical point on the map\r\n\t// stationary (e.g. used internally for scroll zoom and double-click zoom).\r\n\t// @alternative\r\n\t// @method setZoomAround(offset: Point, zoom: Number, options: Zoom options): this\r\n\t// Zooms the map while keeping a specified pixel on the map (relative to the top-left corner) stationary.\r\n\tsetZoomAround: function (latlng, zoom, options) {\r\n\t\tvar scale = this.getZoomScale(zoom),\r\n\t\t    viewHalf = this.getSize().divideBy(2),\r\n\t\t    containerPoint = latlng instanceof Point ? latlng : this.latLngToContainerPoint(latlng),\r\n\r\n\t\t    centerOffset = containerPoint.subtract(viewHalf).multiplyBy(1 - 1 / scale),\r\n\t\t    newCenter = this.containerPointToLatLng(viewHalf.add(centerOffset));\r\n\r\n\t\treturn this.setView(newCenter, zoom, {zoom: options});\r\n\t},\r\n\r\n\t_getBoundsCenterZoom: function (bounds, options) {\r\n\r\n\t\toptions = options || {};\r\n\t\tbounds = bounds.getBounds ? bounds.getBounds() : toLatLngBounds(bounds);\r\n\r\n\t\tvar paddingTL = toPoint(options.paddingTopLeft || options.padding || [0, 0]),\r\n\t\t    paddingBR = toPoint(options.paddingBottomRight || options.padding || [0, 0]),\r\n\r\n\t\t    zoom = this.getBoundsZoom(bounds, false, paddingTL.add(paddingBR));\r\n\r\n\t\tzoom = (typeof options.maxZoom === 'number') ? Math.min(options.maxZoom, zoom) : zoom;\r\n\r\n\t\tif (zoom === Infinity) {\r\n\t\t\treturn {\r\n\t\t\t\tcenter: bounds.getCenter(),\r\n\t\t\t\tzoom: zoom\r\n\t\t\t};\r\n\t\t}\r\n\r\n\t\tvar paddingOffset = paddingBR.subtract(paddingTL).divideBy(2),\r\n\r\n\t\t    swPoint = this.project(bounds.getSouthWest(), zoom),\r\n\t\t    nePoint = this.project(bounds.getNorthEast(), zoom),\r\n\t\t    center = this.unproject(swPoint.add(nePoint).divideBy(2).add(paddingOffset), zoom);\r\n\r\n\t\treturn {\r\n\t\t\tcenter: center,\r\n\t\t\tzoom: zoom\r\n\t\t};\r\n\t},\r\n\r\n\t// @method fitBounds(bounds: LatLngBounds, options?: fitBounds options): this\r\n\t// Sets a map view that contains the given geographical bounds with the\r\n\t// maximum zoom level possible.\r\n\tfitBounds: function (bounds, options) {\r\n\r\n\t\tbounds = toLatLngBounds(bounds);\r\n\r\n\t\tif (!bounds.isValid()) {\r\n\t\t\tthrow new Error('Bounds are not valid.');\r\n\t\t}\r\n\r\n\t\tvar target = this._getBoundsCenterZoom(bounds, options);\r\n\t\treturn this.setView(target.center, target.zoom, options);\r\n\t},\r\n\r\n\t// @method fitWorld(options?: fitBounds options): this\r\n\t// Sets a map view that mostly contains the whole world with the maximum\r\n\t// zoom level possible.\r\n\tfitWorld: function (options) {\r\n\t\treturn this.fitBounds([[-90, -180], [90, 180]], options);\r\n\t},\r\n\r\n\t// @method panTo(latlng: LatLng, options?: Pan options): this\r\n\t// Pans the map to a given center.\r\n\tpanTo: function (center, options) { // (LatLng)\r\n\t\treturn this.setView(center, this._zoom, {pan: options});\r\n\t},\r\n\r\n\t// @method panBy(offset: Point, options?: Pan options): this\r\n\t// Pans the map by a given number of pixels (animated).\r\n\tpanBy: function (offset, options) {\r\n\t\toffset = toPoint(offset).round();\r\n\t\toptions = options || {};\r\n\r\n\t\tif (!offset.x && !offset.y) {\r\n\t\t\treturn this.fire('moveend');\r\n\t\t}\r\n\t\t// If we pan too far, Chrome gets issues with tiles\r\n\t\t// and makes them disappear or appear in the wrong place (slightly offset) #2602\r\n\t\tif (options.animate !== true && !this.getSize().contains(offset)) {\r\n\t\t\tthis._resetView(this.unproject(this.project(this.getCenter()).add(offset)), this.getZoom());\r\n\t\t\treturn this;\r\n\t\t}\r\n\r\n\t\tif (!this._panAnim) {\r\n\t\t\tthis._panAnim = new PosAnimation();\r\n\r\n\t\t\tthis._panAnim.on({\r\n\t\t\t\t'step': this._onPanTransitionStep,\r\n\t\t\t\t'end': this._onPanTransitionEnd\r\n\t\t\t}, this);\r\n\t\t}\r\n\r\n\t\t// don't fire movestart if animating inertia\r\n\t\tif (!options.noMoveStart) {\r\n\t\t\tthis.fire('movestart');\r\n\t\t}\r\n\r\n\t\t// animate pan unless animate: false specified\r\n\t\tif (options.animate !== false) {\r\n\t\t\tDomUtil.addClass(this._mapPane, 'leaflet-pan-anim');\r\n\r\n\t\t\tvar newPos = this._getMapPanePos().subtract(offset).round();\r\n\t\t\tthis._panAnim.run(this._mapPane, newPos, options.duration || 0.25, options.easeLinearity);\r\n\t\t} else {\r\n\t\t\tthis._rawPanBy(offset);\r\n\t\t\tthis.fire('move').fire('moveend');\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\t// @method flyTo(latlng: LatLng, zoom?: Number, options?: Zoom/pan options): this\r\n\t// Sets the view of the map (geographical center and zoom) performing a smooth\r\n\t// pan-zoom animation.\r\n\tflyTo: function (targetCenter, targetZoom, options) {\r\n\r\n\t\toptions = options || {};\r\n\t\tif (options.animate === false || !Browser.any3d) {\r\n\t\t\treturn this.setView(targetCenter, targetZoom, options);\r\n\t\t}\r\n\r\n\t\tthis._stop();\r\n\r\n\t\tvar from = this.project(this.getCenter()),\r\n\t\t    to = this.project(targetCenter),\r\n\t\t    size = this.getSize(),\r\n\t\t    startZoom = this._zoom;\r\n\r\n\t\ttargetCenter = toLatLng(targetCenter);\r\n\t\ttargetZoom = targetZoom === undefined ? startZoom : targetZoom;\r\n\r\n\t\tvar w0 = Math.max(size.x, size.y),\r\n\t\t    w1 = w0 * this.getZoomScale(startZoom, targetZoom),\r\n\t\t    u1 = (to.distanceTo(from)) || 1,\r\n\t\t    rho = 1.42,\r\n\t\t    rho2 = rho * rho;\r\n\r\n\t\tfunction r(i) {\r\n\t\t\tvar s1 = i ? -1 : 1,\r\n\t\t\t    s2 = i ? w1 : w0,\r\n\t\t\t    t1 = w1 * w1 - w0 * w0 + s1 * rho2 * rho2 * u1 * u1,\r\n\t\t\t    b1 = 2 * s2 * rho2 * u1,\r\n\t\t\t    b = t1 / b1,\r\n\t\t\t    sq = Math.sqrt(b * b + 1) - b;\r\n\r\n\t\t\t    // workaround for floating point precision bug when sq = 0, log = -Infinite,\r\n\t\t\t    // thus triggering an infinite loop in flyTo\r\n\t\t\t    var log = sq < 0.000000001 ? -18 : Math.log(sq);\r\n\r\n\t\t\treturn log;\r\n\t\t}\r\n\r\n\t\tfunction sinh(n) { return (Math.exp(n) - Math.exp(-n)) / 2; }\r\n\t\tfunction cosh(n) { return (Math.exp(n) + Math.exp(-n)) / 2; }\r\n\t\tfunction tanh(n) { return sinh(n) / cosh(n); }\r\n\r\n\t\tvar r0 = r(0);\r\n\r\n\t\tfunction w(s) { return w0 * (cosh(r0) / cosh(r0 + rho * s)); }\r\n\t\tfunction u(s) { return w0 * (cosh(r0) * tanh(r0 + rho * s) - sinh(r0)) / rho2; }\r\n\r\n\t\tfunction easeOut(t) { return 1 - Math.pow(1 - t, 1.5); }\r\n\r\n\t\tvar start = Date.now(),\r\n\t\t    S = (r(1) - r0) / rho,\r\n\t\t    duration = options.duration ? 1000 * options.duration : 1000 * S * 0.8;\r\n\r\n\t\tfunction frame() {\r\n\t\t\tvar t = (Date.now() - start) / duration,\r\n\t\t\t    s = easeOut(t) * S;\r\n\r\n\t\t\tif (t <= 1) {\r\n\t\t\t\tthis._flyToFrame = Util.requestAnimFrame(frame, this);\r\n\r\n\t\t\t\tthis._move(\r\n\t\t\t\t\tthis.unproject(from.add(to.subtract(from).multiplyBy(u(s) / u1)), startZoom),\r\n\t\t\t\t\tthis.getScaleZoom(w0 / w(s), startZoom),\r\n\t\t\t\t\t{flyTo: true});\r\n\r\n\t\t\t} else {\r\n\t\t\t\tthis\r\n\t\t\t\t\t._move(targetCenter, targetZoom)\r\n\t\t\t\t\t._moveEnd(true);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis._moveStart(true, options.noMoveStart);\r\n\r\n\t\tframe.call(this);\r\n\t\treturn this;\r\n\t},\r\n\r\n\t// @method flyToBounds(bounds: LatLngBounds, options?: fitBounds options): this\r\n\t// Sets the view of the map with a smooth animation like [`flyTo`](#map-flyto),\r\n\t// but takes a bounds parameter like [`fitBounds`](#map-fitbounds).\r\n\tflyToBounds: function (bounds, options) {\r\n\t\tvar target = this._getBoundsCenterZoom(bounds, options);\r\n\t\treturn this.flyTo(target.center, target.zoom, options);\r\n\t},\r\n\r\n\t// @method setMaxBounds(bounds: LatLngBounds): this\r\n\t// Restricts the map view to the given bounds (see the [maxBounds](#map-maxbounds) option).\r\n\tsetMaxBounds: function (bounds) {\r\n\t\tbounds = toLatLngBounds(bounds);\r\n\r\n\t\tif (this.listens('moveend', this._panInsideMaxBounds)) {\r\n\t\t\tthis.off('moveend', this._panInsideMaxBounds);\r\n\t\t}\r\n\r\n\t\tif (!bounds.isValid()) {\r\n\t\t\tthis.options.maxBounds = null;\r\n\t\t\treturn this;\r\n\t\t}\r\n\r\n\t\tthis.options.maxBounds = bounds;\r\n\r\n\t\tif (this._loaded) {\r\n\t\t\tthis._panInsideMaxBounds();\r\n\t\t}\r\n\r\n\t\treturn this.on('moveend', this._panInsideMaxBounds);\r\n\t},\r\n\r\n\t// @method setMinZoom(zoom: Number): this\r\n\t// Sets the lower limit for the available zoom levels (see the [minZoom](#map-minzoom) option).\r\n\tsetMinZoom: function (zoom) {\r\n\t\tvar oldZoom = this.options.minZoom;\r\n\t\tthis.options.minZoom = zoom;\r\n\r\n\t\tif (this._loaded && oldZoom !== zoom) {\r\n\t\t\tthis.fire('zoomlevelschange');\r\n\r\n\t\t\tif (this.getZoom() < this.options.minZoom) {\r\n\t\t\t\treturn this.setZoom(zoom);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\t// @method setMaxZoom(zoom: Number): this\r\n\t// Sets the upper limit for the available zoom levels (see the [maxZoom](#map-maxzoom) option).\r\n\tsetMaxZoom: function (zoom) {\r\n\t\tvar oldZoom = this.options.maxZoom;\r\n\t\tthis.options.maxZoom = zoom;\r\n\r\n\t\tif (this._loaded && oldZoom !== zoom) {\r\n\t\t\tthis.fire('zoomlevelschange');\r\n\r\n\t\t\tif (this.getZoom() > this.options.maxZoom) {\r\n\t\t\t\treturn this.setZoom(zoom);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\t// @method panInsideBounds(bounds: LatLngBounds, options?: Pan options): this\r\n\t// Pans the map to the closest view that would lie inside the given bounds (if it's not already), controlling the animation using the options specific, if any.\r\n\tpanInsideBounds: function (bounds, options) {\r\n\t\tthis._enforcingBounds = true;\r\n\t\tvar center = this.getCenter(),\r\n\t\t    newCenter = this._limitCenter(center, this._zoom, toLatLngBounds(bounds));\r\n\r\n\t\tif (!center.equals(newCenter)) {\r\n\t\t\tthis.panTo(newCenter, options);\r\n\t\t}\r\n\r\n\t\tthis._enforcingBounds = false;\r\n\t\treturn this;\r\n\t},\r\n\r\n\t// @method panInside(latlng: LatLng, options?: padding options): this\r\n\t// Pans the map the minimum amount to make the `latlng` visible. Use\r\n\t// padding options to fit the display to more restricted bounds.\r\n\t// If `latlng` is already within the (optionally padded) display bounds,\r\n\t// the map will not be panned.\r\n\tpanInside: function (latlng, options) {\r\n\t\toptions = options || {};\r\n\r\n\t\tvar paddingTL = toPoint(options.paddingTopLeft || options.padding || [0, 0]),\r\n\t\t    paddingBR = toPoint(options.paddingBottomRight || options.padding || [0, 0]),\r\n\t\t    pixelCenter = this.project(this.getCenter()),\r\n\t\t    pixelPoint = this.project(latlng),\r\n\t\t    pixelBounds = this.getPixelBounds(),\r\n\t\t    paddedBounds = toBounds([pixelBounds.min.add(paddingTL), pixelBounds.max.subtract(paddingBR)]),\r\n\t\t    paddedSize = paddedBounds.getSize();\r\n\r\n\t\tif (!paddedBounds.contains(pixelPoint)) {\r\n\t\t\tthis._enforcingBounds = true;\r\n\t\t\tvar centerOffset = pixelPoint.subtract(paddedBounds.getCenter());\r\n\t\t\tvar offset = paddedBounds.extend(pixelPoint).getSize().subtract(paddedSize);\r\n\t\t\tpixelCenter.x += centerOffset.x < 0 ? -offset.x : offset.x;\r\n\t\t\tpixelCenter.y += centerOffset.y < 0 ? -offset.y : offset.y;\r\n\t\t\tthis.panTo(this.unproject(pixelCenter), options);\r\n\t\t\tthis._enforcingBounds = false;\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\t// @method invalidateSize(options: Zoom/pan options): this\r\n\t// Checks if the map container size changed and updates the map if so —\r\n\t// call it after you've changed the map size dynamically, also animating\r\n\t// pan by default. If `options.pan` is `false`, panning will not occur.\r\n\t// If `options.debounceMoveend` is `true`, it will delay `moveend` event so\r\n\t// that it doesn't happen often even if the method is called many\r\n\t// times in a row.\r\n\r\n\t// @alternative\r\n\t// @method invalidateSize(animate: Boolean): this\r\n\t// Checks if the map container size changed and updates the map if so —\r\n\t// call it after you've changed the map size dynamically, also animating\r\n\t// pan by default.\r\n\tinvalidateSize: function (options) {\r\n\t\tif (!this._loaded) { return this; }\r\n\r\n\t\toptions = Util.extend({\r\n\t\t\tanimate: false,\r\n\t\t\tpan: true\r\n\t\t}, options === true ? {animate: true} : options);\r\n\r\n\t\tvar oldSize = this.getSize();\r\n\t\tthis._sizeChanged = true;\r\n\t\tthis._lastCenter = null;\r\n\r\n\t\tvar newSize = this.getSize(),\r\n\t\t    oldCenter = oldSize.divideBy(2).round(),\r\n\t\t    newCenter = newSize.divideBy(2).round(),\r\n\t\t    offset = oldCenter.subtract(newCenter);\r\n\r\n\t\tif (!offset.x && !offset.y) { return this; }\r\n\r\n\t\tif (options.animate && options.pan) {\r\n\t\t\tthis.panBy(offset);\r\n\r\n\t\t} else {\r\n\t\t\tif (options.pan) {\r\n\t\t\t\tthis._rawPanBy(offset);\r\n\t\t\t}\r\n\r\n\t\t\tthis.fire('move');\r\n\r\n\t\t\tif (options.debounceMoveend) {\r\n\t\t\t\tclearTimeout(this._sizeTimer);\r\n\t\t\t\tthis._sizeTimer = setTimeout(Util.bind(this.fire, this, 'moveend'), 200);\r\n\t\t\t} else {\r\n\t\t\t\tthis.fire('moveend');\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// @section Map state change events\r\n\t\t// @event resize: ResizeEvent\r\n\t\t// Fired when the map is resized.\r\n\t\treturn this.fire('resize', {\r\n\t\t\toldSize: oldSize,\r\n\t\t\tnewSize: newSize\r\n\t\t});\r\n\t},\r\n\r\n\t// @section Methods for modifying map state\r\n\t// @method stop(): this\r\n\t// Stops the currently running `panTo` or `flyTo` animation, if any.\r\n\tstop: function () {\r\n\t\tthis.setZoom(this._limitZoom(this._zoom));\r\n\t\tif (!this.options.zoomSnap) {\r\n\t\t\tthis.fire('viewreset');\r\n\t\t}\r\n\t\treturn this._stop();\r\n\t},\r\n\r\n\t// @section Geolocation methods\r\n\t// @method locate(options?: Locate options): this\r\n\t// Tries to locate the user using the Geolocation API, firing a [`locationfound`](#map-locationfound)\r\n\t// event with location data on success or a [`locationerror`](#map-locationerror) event on failure,\r\n\t// and optionally sets the map view to the user's location with respect to\r\n\t// detection accuracy (or to the world view if geolocation failed).\r\n\t// Note that, if your page doesn't use HTTPS, this method will fail in\r\n\t// modern browsers ([Chrome 50 and newer](https://sites.google.com/a/chromium.org/dev/Home/chromium-security/deprecating-powerful-features-on-insecure-origins))\r\n\t// See `Locate options` for more details.\r\n\tlocate: function (options) {\r\n\r\n\t\toptions = this._locateOptions = Util.extend({\r\n\t\t\ttimeout: 10000,\r\n\t\t\twatch: false\r\n\t\t\t// setView: false\r\n\t\t\t// maxZoom: <Number>\r\n\t\t\t// maximumAge: 0\r\n\t\t\t// enableHighAccuracy: false\r\n\t\t}, options);\r\n\r\n\t\tif (!('geolocation' in navigator)) {\r\n\t\t\tthis._handleGeolocationError({\r\n\t\t\t\tcode: 0,\r\n\t\t\t\tmessage: 'Geolocation not supported.'\r\n\t\t\t});\r\n\t\t\treturn this;\r\n\t\t}\r\n\r\n\t\tvar onResponse = Util.bind(this._handleGeolocationResponse, this),\r\n\t\t    onError = Util.bind(this._handleGeolocationError, this);\r\n\r\n\t\tif (options.watch) {\r\n\t\t\tthis._locationWatchId =\r\n\t\t\t        navigator.geolocation.watchPosition(onResponse, onError, options);\r\n\t\t} else {\r\n\t\t\tnavigator.geolocation.getCurrentPosition(onResponse, onError, options);\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\t// @method stopLocate(): this\r\n\t// Stops watching location previously initiated by `map.locate({watch: true})`\r\n\t// and aborts resetting the map view if map.locate was called with\r\n\t// `{setView: true}`.\r\n\tstopLocate: function () {\r\n\t\tif (navigator.geolocation && navigator.geolocation.clearWatch) {\r\n\t\t\tnavigator.geolocation.clearWatch(this._locationWatchId);\r\n\t\t}\r\n\t\tif (this._locateOptions) {\r\n\t\t\tthis._locateOptions.setView = false;\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\t_handleGeolocationError: function (error) {\r\n\t\tif (!this._container._leaflet_id) { return; }\r\n\r\n\t\tvar c = error.code,\r\n\t\t    message = error.message ||\r\n\t\t            (c === 1 ? 'permission denied' :\r\n\t\t            (c === 2 ? 'position unavailable' : 'timeout'));\r\n\r\n\t\tif (this._locateOptions.setView && !this._loaded) {\r\n\t\t\tthis.fitWorld();\r\n\t\t}\r\n\r\n\t\t// @section Location events\r\n\t\t// @event locationerror: ErrorEvent\r\n\t\t// Fired when geolocation (using the [`locate`](#map-locate) method) failed.\r\n\t\tthis.fire('locationerror', {\r\n\t\t\tcode: c,\r\n\t\t\tmessage: 'Geolocation error: ' + message + '.'\r\n\t\t});\r\n\t},\r\n\r\n\t_handleGeolocationResponse: function (pos) {\r\n\t\tif (!this._container._leaflet_id) { return; }\r\n\r\n\t\tvar lat = pos.coords.latitude,\r\n\t\t    lng = pos.coords.longitude,\r\n\t\t    latlng = new LatLng(lat, lng),\r\n\t\t    bounds = latlng.toBounds(pos.coords.accuracy * 2),\r\n\t\t    options = this._locateOptions;\r\n\r\n\t\tif (options.setView) {\r\n\t\t\tvar zoom = this.getBoundsZoom(bounds);\r\n\t\t\tthis.setView(latlng, options.maxZoom ? Math.min(zoom, options.maxZoom) : zoom);\r\n\t\t}\r\n\r\n\t\tvar data = {\r\n\t\t\tlatlng: latlng,\r\n\t\t\tbounds: bounds,\r\n\t\t\ttimestamp: pos.timestamp\r\n\t\t};\r\n\r\n\t\tfor (var i in pos.coords) {\r\n\t\t\tif (typeof pos.coords[i] === 'number') {\r\n\t\t\t\tdata[i] = pos.coords[i];\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// @event locationfound: LocationEvent\r\n\t\t// Fired when geolocation (using the [`locate`](#map-locate) method)\r\n\t\t// went successfully.\r\n\t\tthis.fire('locationfound', data);\r\n\t},\r\n\r\n\t// TODO Appropriate docs section?\r\n\t// @section Other Methods\r\n\t// @method addHandler(name: String, HandlerClass: Function): this\r\n\t// Adds a new `Handler` to the map, given its name and constructor function.\r\n\taddHandler: function (name, HandlerClass) {\r\n\t\tif (!HandlerClass) { return this; }\r\n\r\n\t\tvar handler = this[name] = new HandlerClass(this);\r\n\r\n\t\tthis._handlers.push(handler);\r\n\r\n\t\tif (this.options[name]) {\r\n\t\t\thandler.enable();\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\t// @method remove(): this\r\n\t// Destroys the map and clears all related event listeners.\r\n\tremove: function () {\r\n\r\n\t\tthis._initEvents(true);\r\n\t\tif (this.options.maxBounds) { this.off('moveend', this._panInsideMaxBounds); }\r\n\r\n\t\tif (this._containerId !== this._container._leaflet_id) {\r\n\t\t\tthrow new Error('Map container is being reused by another instance');\r\n\t\t}\r\n\r\n\t\ttry {\r\n\t\t\t// throws error in IE6-8\r\n\t\t\tdelete this._container._leaflet_id;\r\n\t\t\tdelete this._containerId;\r\n\t\t} catch (e) {\r\n\t\t\t/*eslint-disable */\r\n\t\t\tthis._container._leaflet_id = undefined;\r\n\t\t\t/* eslint-enable */\r\n\t\t\tthis._containerId = undefined;\r\n\t\t}\r\n\r\n\t\tif (this._locationWatchId !== undefined) {\r\n\t\t\tthis.stopLocate();\r\n\t\t}\r\n\r\n\t\tthis._stop();\r\n\r\n\t\tDomUtil.remove(this._mapPane);\r\n\r\n\t\tif (this._clearControlPos) {\r\n\t\t\tthis._clearControlPos();\r\n\t\t}\r\n\t\tif (this._resizeRequest) {\r\n\t\t\tUtil.cancelAnimFrame(this._resizeRequest);\r\n\t\t\tthis._resizeRequest = null;\r\n\t\t}\r\n\r\n\t\tthis._clearHandlers();\r\n\r\n\t\tif (this._loaded) {\r\n\t\t\t// @section Map state change events\r\n\t\t\t// @event unload: Event\r\n\t\t\t// Fired when the map is destroyed with [remove](#map-remove) method.\r\n\t\t\tthis.fire('unload');\r\n\t\t}\r\n\r\n\t\tvar i;\r\n\t\tfor (i in this._layers) {\r\n\t\t\tthis._layers[i].remove();\r\n\t\t}\r\n\t\tfor (i in this._panes) {\r\n\t\t\tDomUtil.remove(this._panes[i]);\r\n\t\t}\r\n\r\n\t\tthis._layers = [];\r\n\t\tthis._panes = [];\r\n\t\tdelete this._mapPane;\r\n\t\tdelete this._renderer;\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\t// @section Other Methods\r\n\t// @method createPane(name: String, container?: HTMLElement): HTMLElement\r\n\t// Creates a new [map pane](#map-pane) with the given name if it doesn't exist already,\r\n\t// then returns it. The pane is created as a child of `container`, or\r\n\t// as a child of the main map pane if not set.\r\n\tcreatePane: function (name, container) {\r\n\t\tvar className = 'leaflet-pane' + (name ? ' leaflet-' + name.replace('Pane', '') + '-pane' : ''),\r\n\t\t    pane = DomUtil.create('div', className, container || this._mapPane);\r\n\r\n\t\tif (name) {\r\n\t\t\tthis._panes[name] = pane;\r\n\t\t}\r\n\t\treturn pane;\r\n\t},\r\n\r\n\t// @section Methods for Getting Map State\r\n\r\n\t// @method getCenter(): LatLng\r\n\t// Returns the geographical center of the map view\r\n\tgetCenter: function () {\r\n\t\tthis._checkIfLoaded();\r\n\r\n\t\tif (this._lastCenter && !this._moved()) {\r\n\t\t\treturn this._lastCenter.clone();\r\n\t\t}\r\n\t\treturn this.layerPointToLatLng(this._getCenterLayerPoint());\r\n\t},\r\n\r\n\t// @method getZoom(): Number\r\n\t// Returns the current zoom level of the map view\r\n\tgetZoom: function () {\r\n\t\treturn this._zoom;\r\n\t},\r\n\r\n\t// @method getBounds(): LatLngBounds\r\n\t// Returns the geographical bounds visible in the current map view\r\n\tgetBounds: function () {\r\n\t\tvar bounds = this.getPixelBounds(),\r\n\t\t    sw = this.unproject(bounds.getBottomLeft()),\r\n\t\t    ne = this.unproject(bounds.getTopRight());\r\n\r\n\t\treturn new LatLngBounds(sw, ne);\r\n\t},\r\n\r\n\t// @method getMinZoom(): Number\r\n\t// Returns the minimum zoom level of the map (if set in the `minZoom` option of the map or of any layers), or `0` by default.\r\n\tgetMinZoom: function () {\r\n\t\treturn this.options.minZoom === undefined ? this._layersMinZoom || 0 : this.options.minZoom;\r\n\t},\r\n\r\n\t// @method getMaxZoom(): Number\r\n\t// Returns the maximum zoom level of the map (if set in the `maxZoom` option of the map or of any layers).\r\n\tgetMaxZoom: function () {\r\n\t\treturn this.options.maxZoom === undefined ?\r\n\t\t\t(this._layersMaxZoom === undefined ? Infinity : this._layersMaxZoom) :\r\n\t\t\tthis.options.maxZoom;\r\n\t},\r\n\r\n\t// @method getBoundsZoom(bounds: LatLngBounds, inside?: Boolean, padding?: Point): Number\r\n\t// Returns the maximum zoom level on which the given bounds fit to the map\r\n\t// view in its entirety. If `inside` (optional) is set to `true`, the method\r\n\t// instead returns the minimum zoom level on which the map view fits into\r\n\t// the given bounds in its entirety.\r\n\tgetBoundsZoom: function (bounds, inside, padding) { // (LatLngBounds[, Boolean, Point]) -> Number\r\n\t\tbounds = toLatLngBounds(bounds);\r\n\t\tpadding = toPoint(padding || [0, 0]);\r\n\r\n\t\tvar zoom = this.getZoom() || 0,\r\n\t\t    min = this.getMinZoom(),\r\n\t\t    max = this.getMaxZoom(),\r\n\t\t    nw = bounds.getNorthWest(),\r\n\t\t    se = bounds.getSouthEast(),\r\n\t\t    size = this.getSize().subtract(padding),\r\n\t\t    boundsSize = toBounds(this.project(se, zoom), this.project(nw, zoom)).getSize(),\r\n\t\t    snap = Browser.any3d ? this.options.zoomSnap : 1,\r\n\t\t    scalex = size.x / boundsSize.x,\r\n\t\t    scaley = size.y / boundsSize.y,\r\n\t\t    scale = inside ? Math.max(scalex, scaley) : Math.min(scalex, scaley);\r\n\r\n\t\tzoom = this.getScaleZoom(scale, zoom);\r\n\r\n\t\tif (snap) {\r\n\t\t\tzoom = Math.round(zoom / (snap / 100)) * (snap / 100); // don't jump if within 1% of a snap level\r\n\t\t\tzoom = inside ? Math.ceil(zoom / snap) * snap : Math.floor(zoom / snap) * snap;\r\n\t\t}\r\n\r\n\t\treturn Math.max(min, Math.min(max, zoom));\r\n\t},\r\n\r\n\t// @method getSize(): Point\r\n\t// Returns the current size of the map container (in pixels).\r\n\tgetSize: function () {\r\n\t\tif (!this._size || this._sizeChanged) {\r\n\t\t\tthis._size = new Point(\r\n\t\t\t\tthis._container.clientWidth || 0,\r\n\t\t\t\tthis._container.clientHeight || 0);\r\n\r\n\t\t\tthis._sizeChanged = false;\r\n\t\t}\r\n\t\treturn this._size.clone();\r\n\t},\r\n\r\n\t// @method getPixelBounds(): Bounds\r\n\t// Returns the bounds of the current map view in projected pixel\r\n\t// coordinates (sometimes useful in layer and overlay implementations).\r\n\tgetPixelBounds: function (center, zoom) {\r\n\t\tvar topLeftPoint = this._getTopLeftPoint(center, zoom);\r\n\t\treturn new Bounds(topLeftPoint, topLeftPoint.add(this.getSize()));\r\n\t},\r\n\r\n\t// TODO: Check semantics - isn't the pixel origin the 0,0 coord relative to\r\n\t// the map pane? \"left point of the map layer\" can be confusing, specially\r\n\t// since there can be negative offsets.\r\n\t// @method getPixelOrigin(): Point\r\n\t// Returns the projected pixel coordinates of the top left point of\r\n\t// the map layer (useful in custom layer and overlay implementations).\r\n\tgetPixelOrigin: function () {\r\n\t\tthis._checkIfLoaded();\r\n\t\treturn this._pixelOrigin;\r\n\t},\r\n\r\n\t// @method getPixelWorldBounds(zoom?: Number): Bounds\r\n\t// Returns the world's bounds in pixel coordinates for zoom level `zoom`.\r\n\t// If `zoom` is omitted, the map's current zoom level is used.\r\n\tgetPixelWorldBounds: function (zoom) {\r\n\t\treturn this.options.crs.getProjectedBounds(zoom === undefined ? this.getZoom() : zoom);\r\n\t},\r\n\r\n\t// @section Other Methods\r\n\r\n\t// @method getPane(pane: String|HTMLElement): HTMLElement\r\n\t// Returns a [map pane](#map-pane), given its name or its HTML element (its identity).\r\n\tgetPane: function (pane) {\r\n\t\treturn typeof pane === 'string' ? this._panes[pane] : pane;\r\n\t},\r\n\r\n\t// @method getPanes(): Object\r\n\t// Returns a plain object containing the names of all [panes](#map-pane) as keys and\r\n\t// the panes as values.\r\n\tgetPanes: function () {\r\n\t\treturn this._panes;\r\n\t},\r\n\r\n\t// @method getContainer: HTMLElement\r\n\t// Returns the HTML element that contains the map.\r\n\tgetContainer: function () {\r\n\t\treturn this._container;\r\n\t},\r\n\r\n\r\n\t// @section Conversion Methods\r\n\r\n\t// @method getZoomScale(toZoom: Number, fromZoom: Number): Number\r\n\t// Returns the scale factor to be applied to a map transition from zoom level\r\n\t// `fromZoom` to `toZoom`. Used internally to help with zoom animations.\r\n\tgetZoomScale: function (toZoom, fromZoom) {\r\n\t\t// TODO replace with universal implementation after refactoring projections\r\n\t\tvar crs = this.options.crs;\r\n\t\tfromZoom = fromZoom === undefined ? this._zoom : fromZoom;\r\n\t\treturn crs.scale(toZoom) / crs.scale(fromZoom);\r\n\t},\r\n\r\n\t// @method getScaleZoom(scale: Number, fromZoom: Number): Number\r\n\t// Returns the zoom level that the map would end up at, if it is at `fromZoom`\r\n\t// level and everything is scaled by a factor of `scale`. Inverse of\r\n\t// [`getZoomScale`](#map-getZoomScale).\r\n\tgetScaleZoom: function (scale, fromZoom) {\r\n\t\tvar crs = this.options.crs;\r\n\t\tfromZoom = fromZoom === undefined ? this._zoom : fromZoom;\r\n\t\tvar zoom = crs.zoom(scale * crs.scale(fromZoom));\r\n\t\treturn isNaN(zoom) ? Infinity : zoom;\r\n\t},\r\n\r\n\t// @method project(latlng: LatLng, zoom: Number): Point\r\n\t// Projects a geographical coordinate `LatLng` according to the projection\r\n\t// of the map's CRS, then scales it according to `zoom` and the CRS's\r\n\t// `Transformation`. The result is pixel coordinate relative to\r\n\t// the CRS origin.\r\n\tproject: function (latlng, zoom) {\r\n\t\tzoom = zoom === undefined ? this._zoom : zoom;\r\n\t\treturn this.options.crs.latLngToPoint(toLatLng(latlng), zoom);\r\n\t},\r\n\r\n\t// @method unproject(point: Point, zoom: Number): LatLng\r\n\t// Inverse of [`project`](#map-project).\r\n\tunproject: function (point, zoom) {\r\n\t\tzoom = zoom === undefined ? this._zoom : zoom;\r\n\t\treturn this.options.crs.pointToLatLng(toPoint(point), zoom);\r\n\t},\r\n\r\n\t// @method layerPointToLatLng(point: Point): LatLng\r\n\t// Given a pixel coordinate relative to the [origin pixel](#map-getpixelorigin),\r\n\t// returns the corresponding geographical coordinate (for the current zoom level).\r\n\tlayerPointToLatLng: function (point) {\r\n\t\tvar projectedPoint = toPoint(point).add(this.getPixelOrigin());\r\n\t\treturn this.unproject(projectedPoint);\r\n\t},\r\n\r\n\t// @method latLngToLayerPoint(latlng: LatLng): Point\r\n\t// Given a geographical coordinate, returns the corresponding pixel coordinate\r\n\t// relative to the [origin pixel](#map-getpixelorigin).\r\n\tlatLngToLayerPoint: function (latlng) {\r\n\t\tvar projectedPoint = this.project(toLatLng(latlng))._round();\r\n\t\treturn projectedPoint._subtract(this.getPixelOrigin());\r\n\t},\r\n\r\n\t// @method wrapLatLng(latlng: LatLng): LatLng\r\n\t// Returns a `LatLng` where `lat` and `lng` has been wrapped according to the\r\n\t// map's CRS's `wrapLat` and `wrapLng` properties, if they are outside the\r\n\t// CRS's bounds.\r\n\t// By default this means longitude is wrapped around the dateline so its\r\n\t// value is between -180 and +180 degrees.\r\n\twrapLatLng: function (latlng) {\r\n\t\treturn this.options.crs.wrapLatLng(toLatLng(latlng));\r\n\t},\r\n\r\n\t// @method wrapLatLngBounds(bounds: LatLngBounds): LatLngBounds\r\n\t// Returns a `LatLngBounds` with the same size as the given one, ensuring that\r\n\t// its center is within the CRS's bounds.\r\n\t// By default this means the center longitude is wrapped around the dateline so its\r\n\t// value is between -180 and +180 degrees, and the majority of the bounds\r\n\t// overlaps the CRS's bounds.\r\n\twrapLatLngBounds: function (latlng) {\r\n\t\treturn this.options.crs.wrapLatLngBounds(toLatLngBounds(latlng));\r\n\t},\r\n\r\n\t// @method distance(latlng1: LatLng, latlng2: LatLng): Number\r\n\t// Returns the distance between two geographical coordinates according to\r\n\t// the map's CRS. By default this measures distance in meters.\r\n\tdistance: function (latlng1, latlng2) {\r\n\t\treturn this.options.crs.distance(toLatLng(latlng1), toLatLng(latlng2));\r\n\t},\r\n\r\n\t// @method containerPointToLayerPoint(point: Point): Point\r\n\t// Given a pixel coordinate relative to the map container, returns the corresponding\r\n\t// pixel coordinate relative to the [origin pixel](#map-getpixelorigin).\r\n\tcontainerPointToLayerPoint: function (point) { // (Point)\r\n\t\treturn toPoint(point).subtract(this._getMapPanePos());\r\n\t},\r\n\r\n\t// @method layerPointToContainerPoint(point: Point): Point\r\n\t// Given a pixel coordinate relative to the [origin pixel](#map-getpixelorigin),\r\n\t// returns the corresponding pixel coordinate relative to the map container.\r\n\tlayerPointToContainerPoint: function (point) { // (Point)\r\n\t\treturn toPoint(point).add(this._getMapPanePos());\r\n\t},\r\n\r\n\t// @method containerPointToLatLng(point: Point): LatLng\r\n\t// Given a pixel coordinate relative to the map container, returns\r\n\t// the corresponding geographical coordinate (for the current zoom level).\r\n\tcontainerPointToLatLng: function (point) {\r\n\t\tvar layerPoint = this.containerPointToLayerPoint(toPoint(point));\r\n\t\treturn this.layerPointToLatLng(layerPoint);\r\n\t},\r\n\r\n\t// @method latLngToContainerPoint(latlng: LatLng): Point\r\n\t// Given a geographical coordinate, returns the corresponding pixel coordinate\r\n\t// relative to the map container.\r\n\tlatLngToContainerPoint: function (latlng) {\r\n\t\treturn this.layerPointToContainerPoint(this.latLngToLayerPoint(toLatLng(latlng)));\r\n\t},\r\n\r\n\t// @method mouseEventToContainerPoint(ev: MouseEvent): Point\r\n\t// Given a MouseEvent object, returns the pixel coordinate relative to the\r\n\t// map container where the event took place.\r\n\tmouseEventToContainerPoint: function (e) {\r\n\t\treturn DomEvent.getMousePosition(e, this._container);\r\n\t},\r\n\r\n\t// @method mouseEventToLayerPoint(ev: MouseEvent): Point\r\n\t// Given a MouseEvent object, returns the pixel coordinate relative to\r\n\t// the [origin pixel](#map-getpixelorigin) where the event took place.\r\n\tmouseEventToLayerPoint: function (e) {\r\n\t\treturn this.containerPointToLayerPoint(this.mouseEventToContainerPoint(e));\r\n\t},\r\n\r\n\t// @method mouseEventToLatLng(ev: MouseEvent): LatLng\r\n\t// Given a MouseEvent object, returns geographical coordinate where the\r\n\t// event took place.\r\n\tmouseEventToLatLng: function (e) { // (MouseEvent)\r\n\t\treturn this.layerPointToLatLng(this.mouseEventToLayerPoint(e));\r\n\t},\r\n\r\n\r\n\t// map initialization methods\r\n\r\n\t_initContainer: function (id) {\r\n\t\tvar container = this._container = DomUtil.get(id);\r\n\r\n\t\tif (!container) {\r\n\t\t\tthrow new Error('Map container not found.');\r\n\t\t} else if (container._leaflet_id) {\r\n\t\t\tthrow new Error('Map container is already initialized.');\r\n\t\t}\r\n\r\n\t\tDomEvent.on(container, 'scroll', this._onScroll, this);\r\n\t\tthis._containerId = Util.stamp(container);\r\n\t},\r\n\r\n\t_initLayout: function () {\r\n\t\tvar container = this._container;\r\n\r\n\t\tthis._fadeAnimated = this.options.fadeAnimation && Browser.any3d;\r\n\r\n\t\tDomUtil.addClass(container, 'leaflet-container' +\r\n\t\t\t(Browser.touch ? ' leaflet-touch' : '') +\r\n\t\t\t(Browser.retina ? ' leaflet-retina' : '') +\r\n\t\t\t(Browser.ielt9 ? ' leaflet-oldie' : '') +\r\n\t\t\t(Browser.safari ? ' leaflet-safari' : '') +\r\n\t\t\t(this._fadeAnimated ? ' leaflet-fade-anim' : ''));\r\n\r\n\t\tvar position = DomUtil.getStyle(container, 'position');\r\n\r\n\t\tif (position !== 'absolute' && position !== 'relative' && position !== 'fixed' && position !== 'sticky') {\r\n\t\t\tcontainer.style.position = 'relative';\r\n\t\t}\r\n\r\n\t\tthis._initPanes();\r\n\r\n\t\tif (this._initControlPos) {\r\n\t\t\tthis._initControlPos();\r\n\t\t}\r\n\t},\r\n\r\n\t_initPanes: function () {\r\n\t\tvar panes = this._panes = {};\r\n\t\tthis._paneRenderers = {};\r\n\r\n\t\t// @section\r\n\t\t//\r\n\t\t// Panes are DOM elements used to control the ordering of layers on the map. You\r\n\t\t// can access panes with [`map.getPane`](#map-getpane) or\r\n\t\t// [`map.getPanes`](#map-getpanes) methods. New panes can be created with the\r\n\t\t// [`map.createPane`](#map-createpane) method.\r\n\t\t//\r\n\t\t// Every map has the following default panes that differ only in zIndex.\r\n\t\t//\r\n\t\t// @pane mapPane: HTMLElement = 'auto'\r\n\t\t// Pane that contains all other map panes\r\n\r\n\t\tthis._mapPane = this.createPane('mapPane', this._container);\r\n\t\tDomUtil.setPosition(this._mapPane, new Point(0, 0));\r\n\r\n\t\t// @pane tilePane: HTMLElement = 200\r\n\t\t// Pane for `GridLayer`s and `TileLayer`s\r\n\t\tthis.createPane('tilePane');\r\n\t\t// @pane overlayPane: HTMLElement = 400\r\n\t\t// Pane for vectors (`Path`s, like `Polyline`s and `Polygon`s), `ImageOverlay`s and `VideoOverlay`s\r\n\t\tthis.createPane('overlayPane');\r\n\t\t// @pane shadowPane: HTMLElement = 500\r\n\t\t// Pane for overlay shadows (e.g. `Marker` shadows)\r\n\t\tthis.createPane('shadowPane');\r\n\t\t// @pane markerPane: HTMLElement = 600\r\n\t\t// Pane for `Icon`s of `Marker`s\r\n\t\tthis.createPane('markerPane');\r\n\t\t// @pane tooltipPane: HTMLElement = 650\r\n\t\t// Pane for `Tooltip`s.\r\n\t\tthis.createPane('tooltipPane');\r\n\t\t// @pane popupPane: HTMLElement = 700\r\n\t\t// Pane for `Popup`s.\r\n\t\tthis.createPane('popupPane');\r\n\r\n\t\tif (!this.options.markerZoomAnimation) {\r\n\t\t\tDomUtil.addClass(panes.markerPane, 'leaflet-zoom-hide');\r\n\t\t\tDomUtil.addClass(panes.shadowPane, 'leaflet-zoom-hide');\r\n\t\t}\r\n\t},\r\n\r\n\r\n\t// private methods that modify map state\r\n\r\n\t// @section Map state change events\r\n\t_resetView: function (center, zoom, noMoveStart) {\r\n\t\tDomUtil.setPosition(this._mapPane, new Point(0, 0));\r\n\r\n\t\tvar loading = !this._loaded;\r\n\t\tthis._loaded = true;\r\n\t\tzoom = this._limitZoom(zoom);\r\n\r\n\t\tthis.fire('viewprereset');\r\n\r\n\t\tvar zoomChanged = this._zoom !== zoom;\r\n\t\tthis\r\n\t\t\t._moveStart(zoomChanged, noMoveStart)\r\n\t\t\t._move(center, zoom)\r\n\t\t\t._moveEnd(zoomChanged);\r\n\r\n\t\t// @event viewreset: Event\r\n\t\t// Fired when the map needs to redraw its content (this usually happens\r\n\t\t// on map zoom or load). Very useful for creating custom overlays.\r\n\t\tthis.fire('viewreset');\r\n\r\n\t\t// @event load: Event\r\n\t\t// Fired when the map is initialized (when its center and zoom are set\r\n\t\t// for the first time).\r\n\t\tif (loading) {\r\n\t\t\tthis.fire('load');\r\n\t\t}\r\n\t},\r\n\r\n\t_moveStart: function (zoomChanged, noMoveStart) {\r\n\t\t// @event zoomstart: Event\r\n\t\t// Fired when the map zoom is about to change (e.g. before zoom animation).\r\n\t\t// @event movestart: Event\r\n\t\t// Fired when the view of the map starts changing (e.g. user starts dragging the map).\r\n\t\tif (zoomChanged) {\r\n\t\t\tthis.fire('zoomstart');\r\n\t\t}\r\n\t\tif (!noMoveStart) {\r\n\t\t\tthis.fire('movestart');\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\t_move: function (center, zoom, data, supressEvent) {\r\n\t\tif (zoom === undefined) {\r\n\t\t\tzoom = this._zoom;\r\n\t\t}\r\n\t\tvar zoomChanged = this._zoom !== zoom;\r\n\r\n\t\tthis._zoom = zoom;\r\n\t\tthis._lastCenter = center;\r\n\t\tthis._pixelOrigin = this._getNewPixelOrigin(center);\r\n\r\n\t\tif (!supressEvent) {\r\n\t\t\t// @event zoom: Event\r\n\t\t\t// Fired repeatedly during any change in zoom level,\r\n\t\t\t// including zoom and fly animations.\r\n\t\t\tif (zoomChanged || (data && data.pinch)) {\t// Always fire 'zoom' if pinching because #3530\r\n\t\t\t\tthis.fire('zoom', data);\r\n\t\t\t}\r\n\r\n\t\t\t// @event move: Event\r\n\t\t\t// Fired repeatedly during any movement of the map,\r\n\t\t\t// including pan and fly animations.\r\n\t\t\tthis.fire('move', data);\r\n\t\t} else if (data && data.pinch) {\t// Always fire 'zoom' if pinching because #3530\r\n\t\t\tthis.fire('zoom', data);\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\t_moveEnd: function (zoomChanged) {\r\n\t\t// @event zoomend: Event\r\n\t\t// Fired when the map zoom changed, after any animations.\r\n\t\tif (zoomChanged) {\r\n\t\t\tthis.fire('zoomend');\r\n\t\t}\r\n\r\n\t\t// @event moveend: Event\r\n\t\t// Fired when the center of the map stops changing\r\n\t\t// (e.g. user stopped dragging the map or after non-centered zoom).\r\n\t\treturn this.fire('moveend');\r\n\t},\r\n\r\n\t_stop: function () {\r\n\t\tUtil.cancelAnimFrame(this._flyToFrame);\r\n\t\tif (this._panAnim) {\r\n\t\t\tthis._panAnim.stop();\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\t_rawPanBy: function (offset) {\r\n\t\tDomUtil.setPosition(this._mapPane, this._getMapPanePos().subtract(offset));\r\n\t},\r\n\r\n\t_getZoomSpan: function () {\r\n\t\treturn this.getMaxZoom() - this.getMinZoom();\r\n\t},\r\n\r\n\t_panInsideMaxBounds: function () {\r\n\t\tif (!this._enforcingBounds) {\r\n\t\t\tthis.panInsideBounds(this.options.maxBounds);\r\n\t\t}\r\n\t},\r\n\r\n\t_checkIfLoaded: function () {\r\n\t\tif (!this._loaded) {\r\n\t\t\tthrow new Error('Set map center and zoom first.');\r\n\t\t}\r\n\t},\r\n\r\n\t// DOM event handling\r\n\r\n\t// @section Interaction events\r\n\t_initEvents: function (remove) {\r\n\t\tthis._targets = {};\r\n\t\tthis._targets[Util.stamp(this._container)] = this;\r\n\r\n\t\tvar onOff = remove ? DomEvent.off : DomEvent.on;\r\n\r\n\t\t// @event click: MouseEvent\r\n\t\t// Fired when the user clicks (or taps) the map.\r\n\t\t// @event dblclick: MouseEvent\r\n\t\t// Fired when the user double-clicks (or double-taps) the map.\r\n\t\t// @event mousedown: MouseEvent\r\n\t\t// Fired when the user pushes the mouse button on the map.\r\n\t\t// @event mouseup: MouseEvent\r\n\t\t// Fired when the user releases the mouse button on the map.\r\n\t\t// @event mouseover: MouseEvent\r\n\t\t// Fired when the mouse enters the map.\r\n\t\t// @event mouseout: MouseEvent\r\n\t\t// Fired when the mouse leaves the map.\r\n\t\t// @event mousemove: MouseEvent\r\n\t\t// Fired while the mouse moves over the map.\r\n\t\t// @event contextmenu: MouseEvent\r\n\t\t// Fired when the user pushes the right mouse button on the map, prevents\r\n\t\t// default browser context menu from showing if there are listeners on\r\n\t\t// this event. Also fired on mobile when the user holds a single touch\r\n\t\t// for a second (also called long press).\r\n\t\t// @event keypress: KeyboardEvent\r\n\t\t// Fired when the user presses a key from the keyboard that produces a character value while the map is focused.\r\n\t\t// @event keydown: KeyboardEvent\r\n\t\t// Fired when the user presses a key from the keyboard while the map is focused. Unlike the `keypress` event,\r\n\t\t// the `keydown` event is fired for keys that produce a character value and for keys\r\n\t\t// that do not produce a character value.\r\n\t\t// @event keyup: KeyboardEvent\r\n\t\t// Fired when the user releases a key from the keyboard while the map is focused.\r\n\t\tonOff(this._container, 'click dblclick mousedown mouseup ' +\r\n\t\t\t'mouseover mouseout mousemove contextmenu keypress keydown keyup', this._handleDOMEvent, this);\r\n\r\n\t\tif (this.options.trackResize) {\r\n\t\t\tonOff(window, 'resize', this._onResize, this);\r\n\t\t}\r\n\r\n\t\tif (Browser.any3d && this.options.transform3DLimit) {\r\n\t\t\t(remove ? this.off : this.on).call(this, 'moveend', this._onMoveEnd);\r\n\t\t}\r\n\t},\r\n\r\n\t_onResize: function () {\r\n\t\tUtil.cancelAnimFrame(this._resizeRequest);\r\n\t\tthis._resizeRequest = Util.requestAnimFrame(\r\n\t\t        function () { this.invalidateSize({debounceMoveend: true}); }, this);\r\n\t},\r\n\r\n\t_onScroll: function () {\r\n\t\tthis._container.scrollTop  = 0;\r\n\t\tthis._container.scrollLeft = 0;\r\n\t},\r\n\r\n\t_onMoveEnd: function () {\r\n\t\tvar pos = this._getMapPanePos();\r\n\t\tif (Math.max(Math.abs(pos.x), Math.abs(pos.y)) >= this.options.transform3DLimit) {\r\n\t\t\t// https://bugzilla.mozilla.org/show_bug.cgi?id=1203873 but Webkit also have\r\n\t\t\t// a pixel offset on very high values, see: https://jsfiddle.net/dg6r5hhb/\r\n\t\t\tthis._resetView(this.getCenter(), this.getZoom());\r\n\t\t}\r\n\t},\r\n\r\n\t_findEventTargets: function (e, type) {\r\n\t\tvar targets = [],\r\n\t\t    target,\r\n\t\t    isHover = type === 'mouseout' || type === 'mouseover',\r\n\t\t    src = e.target || e.srcElement,\r\n\t\t    dragging = false;\r\n\r\n\t\twhile (src) {\r\n\t\t\ttarget = this._targets[Util.stamp(src)];\r\n\t\t\tif (target && (type === 'click' || type === 'preclick') && this._draggableMoved(target)) {\r\n\t\t\t\t// Prevent firing click after you just dragged an object.\r\n\t\t\t\tdragging = true;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tif (target && target.listens(type, true)) {\r\n\t\t\t\tif (isHover && !DomEvent.isExternalTarget(src, e)) { break; }\r\n\t\t\t\ttargets.push(target);\r\n\t\t\t\tif (isHover) { break; }\r\n\t\t\t}\r\n\t\t\tif (src === this._container) { break; }\r\n\t\t\tsrc = src.parentNode;\r\n\t\t}\r\n\t\tif (!targets.length && !dragging && !isHover && this.listens(type, true)) {\r\n\t\t\ttargets = [this];\r\n\t\t}\r\n\t\treturn targets;\r\n\t},\r\n\r\n\t_isClickDisabled: function (el) {\r\n\t\twhile (el && el !== this._container) {\r\n\t\t\tif (el['_leaflet_disable_click']) { return true; }\r\n\t\t\tel = el.parentNode;\r\n\t\t}\r\n\t},\r\n\r\n\t_handleDOMEvent: function (e) {\r\n\t\tvar el = (e.target || e.srcElement);\r\n\t\tif (!this._loaded || el['_leaflet_disable_events'] || e.type === 'click' && this._isClickDisabled(el)) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tvar type = e.type;\r\n\r\n\t\tif (type === 'mousedown') {\r\n\t\t\t// prevents outline when clicking on keyboard-focusable element\r\n\t\t\tDomUtil.preventOutline(el);\r\n\t\t}\r\n\r\n\t\tthis._fireDOMEvent(e, type);\r\n\t},\r\n\r\n\t_mouseEvents: ['click', 'dblclick', 'mouseover', 'mouseout', 'contextmenu'],\r\n\r\n\t_fireDOMEvent: function (e, type, canvasTargets) {\r\n\r\n\t\tif (e.type === 'click') {\r\n\t\t\t// Fire a synthetic 'preclick' event which propagates up (mainly for closing popups).\r\n\t\t\t// @event preclick: MouseEvent\r\n\t\t\t// Fired before mouse click on the map (sometimes useful when you\r\n\t\t\t// want something to happen on click before any existing click\r\n\t\t\t// handlers start running).\r\n\t\t\tvar synth = Util.extend({}, e);\r\n\t\t\tsynth.type = 'preclick';\r\n\t\t\tthis._fireDOMEvent(synth, synth.type, canvasTargets);\r\n\t\t}\r\n\r\n\t\t// Find the layer the event is propagating from and its parents.\r\n\t\tvar targets = this._findEventTargets(e, type);\r\n\r\n\t\tif (canvasTargets) {\r\n\t\t\tvar filtered = []; // pick only targets with listeners\r\n\t\t\tfor (var i = 0; i < canvasTargets.length; i++) {\r\n\t\t\t\tif (canvasTargets[i].listens(type, true)) {\r\n\t\t\t\t\tfiltered.push(canvasTargets[i]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\ttargets = filtered.concat(targets);\r\n\t\t}\r\n\r\n\t\tif (!targets.length) { return; }\r\n\r\n\t\tif (type === 'contextmenu') {\r\n\t\t\tDomEvent.preventDefault(e);\r\n\t\t}\r\n\r\n\t\tvar target = targets[0];\r\n\t\tvar data = {\r\n\t\t\toriginalEvent: e\r\n\t\t};\r\n\r\n\t\tif (e.type !== 'keypress' && e.type !== 'keydown' && e.type !== 'keyup') {\r\n\t\t\tvar isMarker = target.getLatLng && (!target._radius || target._radius <= 10);\r\n\t\t\tdata.containerPoint = isMarker ?\r\n\t\t\t\tthis.latLngToContainerPoint(target.getLatLng()) : this.mouseEventToContainerPoint(e);\r\n\t\t\tdata.layerPoint = this.containerPointToLayerPoint(data.containerPoint);\r\n\t\t\tdata.latlng = isMarker ? target.getLatLng() : this.layerPointToLatLng(data.layerPoint);\r\n\t\t}\r\n\r\n\t\tfor (i = 0; i < targets.length; i++) {\r\n\t\t\ttargets[i].fire(type, data, true);\r\n\t\t\tif (data.originalEvent._stopped ||\r\n\t\t\t\t(targets[i].options.bubblingMouseEvents === false && Util.indexOf(this._mouseEvents, type) !== -1)) { return; }\r\n\t\t}\r\n\t},\r\n\r\n\t_draggableMoved: function (obj) {\r\n\t\tobj = obj.dragging && obj.dragging.enabled() ? obj : this;\r\n\t\treturn (obj.dragging && obj.dragging.moved()) || (this.boxZoom && this.boxZoom.moved());\r\n\t},\r\n\r\n\t_clearHandlers: function () {\r\n\t\tfor (var i = 0, len = this._handlers.length; i < len; i++) {\r\n\t\t\tthis._handlers[i].disable();\r\n\t\t}\r\n\t},\r\n\r\n\t// @section Other Methods\r\n\r\n\t// @method whenReady(fn: Function, context?: Object): this\r\n\t// Runs the given function `fn` when the map gets initialized with\r\n\t// a view (center and zoom) and at least one layer, or immediately\r\n\t// if it's already initialized, optionally passing a function context.\r\n\twhenReady: function (callback, context) {\r\n\t\tif (this._loaded) {\r\n\t\t\tcallback.call(context || this, {target: this});\r\n\t\t} else {\r\n\t\t\tthis.on('load', callback, context);\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\r\n\t// private methods for getting map state\r\n\r\n\t_getMapPanePos: function () {\r\n\t\treturn DomUtil.getPosition(this._mapPane) || new Point(0, 0);\r\n\t},\r\n\r\n\t_moved: function () {\r\n\t\tvar pos = this._getMapPanePos();\r\n\t\treturn pos && !pos.equals([0, 0]);\r\n\t},\r\n\r\n\t_getTopLeftPoint: function (center, zoom) {\r\n\t\tvar pixelOrigin = center && zoom !== undefined ?\r\n\t\t\tthis._getNewPixelOrigin(center, zoom) :\r\n\t\t\tthis.getPixelOrigin();\r\n\t\treturn pixelOrigin.subtract(this._getMapPanePos());\r\n\t},\r\n\r\n\t_getNewPixelOrigin: function (center, zoom) {\r\n\t\tvar viewHalf = this.getSize()._divideBy(2);\r\n\t\treturn this.project(center, zoom)._subtract(viewHalf)._add(this._getMapPanePos())._round();\r\n\t},\r\n\r\n\t_latLngToNewLayerPoint: function (latlng, zoom, center) {\r\n\t\tvar topLeft = this._getNewPixelOrigin(center, zoom);\r\n\t\treturn this.project(latlng, zoom)._subtract(topLeft);\r\n\t},\r\n\r\n\t_latLngBoundsToNewLayerBounds: function (latLngBounds, zoom, center) {\r\n\t\tvar topLeft = this._getNewPixelOrigin(center, zoom);\r\n\t\treturn toBounds([\r\n\t\t\tthis.project(latLngBounds.getSouthWest(), zoom)._subtract(topLeft),\r\n\t\t\tthis.project(latLngBounds.getNorthWest(), zoom)._subtract(topLeft),\r\n\t\t\tthis.project(latLngBounds.getSouthEast(), zoom)._subtract(topLeft),\r\n\t\t\tthis.project(latLngBounds.getNorthEast(), zoom)._subtract(topLeft)\r\n\t\t]);\r\n\t},\r\n\r\n\t// layer point of the current center\r\n\t_getCenterLayerPoint: function () {\r\n\t\treturn this.containerPointToLayerPoint(this.getSize()._divideBy(2));\r\n\t},\r\n\r\n\t// offset of the specified place to the current center in pixels\r\n\t_getCenterOffset: function (latlng) {\r\n\t\treturn this.latLngToLayerPoint(latlng).subtract(this._getCenterLayerPoint());\r\n\t},\r\n\r\n\t// adjust center for view to get inside bounds\r\n\t_limitCenter: function (center, zoom, bounds) {\r\n\r\n\t\tif (!bounds) { return center; }\r\n\r\n\t\tvar centerPoint = this.project(center, zoom),\r\n\t\t    viewHalf = this.getSize().divideBy(2),\r\n\t\t    viewBounds = new Bounds(centerPoint.subtract(viewHalf), centerPoint.add(viewHalf)),\r\n\t\t    offset = this._getBoundsOffset(viewBounds, bounds, zoom);\r\n\r\n\t\t// If offset is less than a pixel, ignore.\r\n\t\t// This prevents unstable projections from getting into\r\n\t\t// an infinite loop of tiny offsets.\r\n\t\tif (Math.abs(offset.x) <= 1 && Math.abs(offset.y) <= 1) {\r\n\t\t\treturn center;\r\n\t\t}\r\n\r\n\t\treturn this.unproject(centerPoint.add(offset), zoom);\r\n\t},\r\n\r\n\t// adjust offset for view to get inside bounds\r\n\t_limitOffset: function (offset, bounds) {\r\n\t\tif (!bounds) { return offset; }\r\n\r\n\t\tvar viewBounds = this.getPixelBounds(),\r\n\t\t    newBounds = new Bounds(viewBounds.min.add(offset), viewBounds.max.add(offset));\r\n\r\n\t\treturn offset.add(this._getBoundsOffset(newBounds, bounds));\r\n\t},\r\n\r\n\t// returns offset needed for pxBounds to get inside maxBounds at a specified zoom\r\n\t_getBoundsOffset: function (pxBounds, maxBounds, zoom) {\r\n\t\tvar projectedMaxBounds = toBounds(\r\n\t\t        this.project(maxBounds.getNorthEast(), zoom),\r\n\t\t        this.project(maxBounds.getSouthWest(), zoom)\r\n\t\t    ),\r\n\t\t    minOffset = projectedMaxBounds.min.subtract(pxBounds.min),\r\n\t\t    maxOffset = projectedMaxBounds.max.subtract(pxBounds.max),\r\n\r\n\t\t    dx = this._rebound(minOffset.x, -maxOffset.x),\r\n\t\t    dy = this._rebound(minOffset.y, -maxOffset.y);\r\n\r\n\t\treturn new Point(dx, dy);\r\n\t},\r\n\r\n\t_rebound: function (left, right) {\r\n\t\treturn left + right > 0 ?\r\n\t\t\tMath.round(left - right) / 2 :\r\n\t\t\tMath.max(0, Math.ceil(left)) - Math.max(0, Math.floor(right));\r\n\t},\r\n\r\n\t_limitZoom: function (zoom) {\r\n\t\tvar min = this.getMinZoom(),\r\n\t\t    max = this.getMaxZoom(),\r\n\t\t    snap = Browser.any3d ? this.options.zoomSnap : 1;\r\n\t\tif (snap) {\r\n\t\t\tzoom = Math.round(zoom / snap) * snap;\r\n\t\t}\r\n\t\treturn Math.max(min, Math.min(max, zoom));\r\n\t},\r\n\r\n\t_onPanTransitionStep: function () {\r\n\t\tthis.fire('move');\r\n\t},\r\n\r\n\t_onPanTransitionEnd: function () {\r\n\t\tDomUtil.removeClass(this._mapPane, 'leaflet-pan-anim');\r\n\t\tthis.fire('moveend');\r\n\t},\r\n\r\n\t_tryAnimatedPan: function (center, options) {\r\n\t\t// difference between the new and current centers in pixels\r\n\t\tvar offset = this._getCenterOffset(center)._trunc();\r\n\r\n\t\t// don't animate too far unless animate: true specified in options\r\n\t\tif ((options && options.animate) !== true && !this.getSize().contains(offset)) { return false; }\r\n\r\n\t\tthis.panBy(offset, options);\r\n\r\n\t\treturn true;\r\n\t},\r\n\r\n\t_createAnimProxy: function () {\r\n\r\n\t\tvar proxy = this._proxy = DomUtil.create('div', 'leaflet-proxy leaflet-zoom-animated');\r\n\t\tthis._panes.mapPane.appendChild(proxy);\r\n\r\n\t\tthis.on('zoomanim', function (e) {\r\n\t\t\tvar prop = DomUtil.TRANSFORM,\r\n\t\t\t    transform = this._proxy.style[prop];\r\n\r\n\t\t\tDomUtil.setTransform(this._proxy, this.project(e.center, e.zoom), this.getZoomScale(e.zoom, 1));\r\n\r\n\t\t\t// workaround for case when transform is the same and so transitionend event is not fired\r\n\t\t\tif (transform === this._proxy.style[prop] && this._animatingZoom) {\r\n\t\t\t\tthis._onZoomTransitionEnd();\r\n\t\t\t}\r\n\t\t}, this);\r\n\r\n\t\tthis.on('load moveend', this._animMoveEnd, this);\r\n\r\n\t\tthis._on('unload', this._destroyAnimProxy, this);\r\n\t},\r\n\r\n\t_destroyAnimProxy: function () {\r\n\t\tDomUtil.remove(this._proxy);\r\n\t\tthis.off('load moveend', this._animMoveEnd, this);\r\n\t\tdelete this._proxy;\r\n\t},\r\n\r\n\t_animMoveEnd: function () {\r\n\t\tvar c = this.getCenter(),\r\n\t\t    z = this.getZoom();\r\n\t\tDomUtil.setTransform(this._proxy, this.project(c, z), this.getZoomScale(z, 1));\r\n\t},\r\n\r\n\t_catchTransitionEnd: function (e) {\r\n\t\tif (this._animatingZoom && e.propertyName.indexOf('transform') >= 0) {\r\n\t\t\tthis._onZoomTransitionEnd();\r\n\t\t}\r\n\t},\r\n\r\n\t_nothingToAnimate: function () {\r\n\t\treturn !this._container.getElementsByClassName('leaflet-zoom-animated').length;\r\n\t},\r\n\r\n\t_tryAnimatedZoom: function (center, zoom, options) {\r\n\r\n\t\tif (this._animatingZoom) { return true; }\r\n\r\n\t\toptions = options || {};\r\n\r\n\t\t// don't animate if disabled, not supported or zoom difference is too large\r\n\t\tif (!this._zoomAnimated || options.animate === false || this._nothingToAnimate() ||\r\n\t\t        Math.abs(zoom - this._zoom) > this.options.zoomAnimationThreshold) { return false; }\r\n\r\n\t\t// offset is the pixel coords of the zoom origin relative to the current center\r\n\t\tvar scale = this.getZoomScale(zoom),\r\n\t\t    offset = this._getCenterOffset(center)._divideBy(1 - 1 / scale);\r\n\r\n\t\t// don't animate if the zoom origin isn't within one screen from the current center, unless forced\r\n\t\tif (options.animate !== true && !this.getSize().contains(offset)) { return false; }\r\n\r\n\t\tUtil.requestAnimFrame(function () {\r\n\t\t\tthis\r\n\t\t\t    ._moveStart(true, false)\r\n\t\t\t    ._animateZoom(center, zoom, true);\r\n\t\t}, this);\r\n\r\n\t\treturn true;\r\n\t},\r\n\r\n\t_animateZoom: function (center, zoom, startAnim, noUpdate) {\r\n\t\tif (!this._mapPane) { return; }\r\n\r\n\t\tif (startAnim) {\r\n\t\t\tthis._animatingZoom = true;\r\n\r\n\t\t\t// remember what center/zoom to set after animation\r\n\t\t\tthis._animateToCenter = center;\r\n\t\t\tthis._animateToZoom = zoom;\r\n\r\n\t\t\tDomUtil.addClass(this._mapPane, 'leaflet-zoom-anim');\r\n\t\t}\r\n\r\n\t\t// @section Other Events\r\n\t\t// @event zoomanim: ZoomAnimEvent\r\n\t\t// Fired at least once per zoom animation. For continuous zoom, like pinch zooming, fired once per frame during zoom.\r\n\t\tthis.fire('zoomanim', {\r\n\t\t\tcenter: center,\r\n\t\t\tzoom: zoom,\r\n\t\t\tnoUpdate: noUpdate\r\n\t\t});\r\n\r\n\t\tif (!this._tempFireZoomEvent) {\r\n\t\t\tthis._tempFireZoomEvent = this._zoom !== this._animateToZoom;\r\n\t\t}\r\n\r\n\t\tthis._move(this._animateToCenter, this._animateToZoom, undefined, true);\r\n\r\n\t\t// Work around webkit not firing 'transitionend', see https://github.com/Leaflet/Leaflet/issues/3689, 2693\r\n\t\tsetTimeout(Util.bind(this._onZoomTransitionEnd, this), 250);\r\n\t},\r\n\r\n\t_onZoomTransitionEnd: function () {\r\n\t\tif (!this._animatingZoom) { return; }\r\n\r\n\t\tif (this._mapPane) {\r\n\t\t\tDomUtil.removeClass(this._mapPane, 'leaflet-zoom-anim');\r\n\t\t}\r\n\r\n\t\tthis._animatingZoom = false;\r\n\r\n\t\tthis._move(this._animateToCenter, this._animateToZoom, undefined, true);\r\n\r\n\t\tif (this._tempFireZoomEvent) {\r\n\t\t\tthis.fire('zoom');\r\n\t\t}\r\n\t\tdelete this._tempFireZoomEvent;\r\n\r\n\t\tthis.fire('move');\r\n\r\n\t\tthis._moveEnd(true);\r\n\t}\r\n});\r\n\r\n// @section\r\n\r\n// @factory L.map(id: String, options?: Map options)\r\n// Instantiates a map object given the DOM ID of a `<div>` element\r\n// and optionally an object literal with `Map options`.\r\n//\r\n// @alternative\r\n// @factory L.map(el: HTMLElement, options?: Map options)\r\n// Instantiates a map object given an instance of a `<div>` HTML element\r\n// and optionally an object literal with `Map options`.\r\nexport function createMap(id, options) {\r\n\treturn new Map(id, options);\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}